
# generated by tools/generate.py
# https://github.com/esoma/pyglm_typing/

import ctypes
from typing import (Any, Callable, Generator, Generic, Iterable, List, Literal,
                    Optional, SupportsInt, Tuple, Type, TypeVar, Union,
                    overload)

import glm_typing

_T = TypeVar('_T')
_VT = TypeVar('_VT', bvec1, bvec2, bvec3, bvec4, dmvec2, dmvec3, dmvec4, dvec1, dvec2, dvec3, dvec4, i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, i8vec2, i8vec3, i8vec4, imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4, mvec2, mvec3, mvec4, u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, u8vec2, u8vec3, u8vec4, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4, vec1, vec2, vec3, vec4)
_NF32VT = TypeVar('_NF32VT', bvec1, bvec2, bvec3, bvec4, dmvec2, dmvec3, dmvec4, dvec1, dvec2, dvec3, dvec4, i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, i8vec2, i8vec3, i8vec4, imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4, u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, u8vec2, u8vec3, u8vec4, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4)
_FDVT = TypeVar('_FDVT', dmvec2, dmvec3, dmvec4, dvec1, dvec2, dvec3, dvec4, mvec2, mvec3, mvec4, vec1, vec2, vec3, vec4)
_NF32DFVT = TypeVar('_NF32DFVT', dmvec2, dmvec3, dmvec4, dvec1, dvec2, dvec3, dvec4)
_NF32DFV1T = TypeVar('_NF32DFV1T', bound=dvec1)
_NF32DFV2T = TypeVar('_NF32DFV2T', dmvec2, dvec2)
_NF32DFV3T = TypeVar('_NF32DFV3T', dmvec3, dvec3)
_NF32DFV4T = TypeVar('_NF32DFV4T', dmvec4, dvec4)
_NF32V1T = TypeVar('_NF32V1T', bvec1, dvec1, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, uvec1)
_NF32V2T = TypeVar('_NF32V2T', bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2)
_NF32V3T = TypeVar('_NF32V3T', bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3)
_NF32V4T = TypeVar('_NF32V4T', bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4)
_IVT = TypeVar('_IVT', i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, i8vec2, i8vec3, i8vec4, imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4)
_UVT = TypeVar('_UVT', u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, u8vec2, u8vec3, u8vec4, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4)
_NI32IUVT = TypeVar('_NI32IUVT', i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, i8vec2, i8vec3, i8vec4, u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, u8vec2, u8vec3, u8vec4, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4)
_NF32FDMSQRT = TypeVar('_NF32FDMSQRT', dmat2x2, dmat3x3, dmat4x4)
_NF32M2XNT = TypeVar('_NF32M2XNT', dmat2x2, dmat2x3, dmat2x4, imat2x2, imat2x3, imat2x4, umat2x2, umat2x3, umat2x4)
_NF32M3XNT = TypeVar('_NF32M3XNT', dmat3x2, dmat3x3, dmat3x4, imat3x2, imat3x3, imat3x4, umat3x2, umat3x3, umat3x4)
_NF32M4XNT = TypeVar('_NF32M4XNT', dmat4x2, dmat4x3, dmat4x4, imat4x2, imat4x3, imat4x4, umat4x2, umat4x3, umat4x4)
_NF32M2X2T = TypeVar('_NF32M2X2T', dmat2x2, imat2x2, umat2x2)
_NF32M2X3T = TypeVar('_NF32M2X3T', dmat2x3, imat2x3, umat2x3)
_NF32M2X4T = TypeVar('_NF32M2X4T', dmat2x4, imat2x4, umat2x4)
_NF32M3X2T = TypeVar('_NF32M3X2T', dmat3x2, imat3x2, umat3x2)
_NF32M3X3T = TypeVar('_NF32M3X3T', dmat3x3, imat3x3, umat3x3)
_NF32M3X4T = TypeVar('_NF32M3X4T', dmat3x4, imat3x4, umat3x4)
_NF32M4X2T = TypeVar('_NF32M4X2T', dmat4x2, imat4x2, umat4x2)
_NF32M4X3T = TypeVar('_NF32M4X3T', dmat4x3, imat4x3, umat4x3)
_NF32M4X4T = TypeVar('_NF32M4X4T', dmat4x4, imat4x4, umat4x4)
_QT = TypeVar('_QT', dquat, quat)

bool_ = ctypes.c_bool
c_int16 = ctypes.c_short
int16 = ctypes.c_short
c_int32 = ctypes.c_long
int32 = ctypes.c_long
c_int64 = ctypes.c_longlong
int64 = ctypes.c_longlong
c_int8 = ctypes.c_byte
int8 = ctypes.c_byte
c_uint16 = ctypes.c_ushort
uint16 = ctypes.c_ushort
c_uint32 = ctypes.c_ulong
uint32 = ctypes.c_ulong
c_uint64 = ctypes.c_ulonglong
uint64 = ctypes.c_ulonglong
c_uint8 = ctypes.c_ubyte
uint8 = ctypes.c_ubyte
double = ctypes.c_double
float64 = ctypes.c_double
float32 = ctypes.c_float
float_ = ctypes.c_float


class bvec1:
    x: bool

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector1, glm_typing.BAnyVector2, glm_typing.BAnyVector3, glm_typing.BAnyVector4]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[bool, None, None]: ...

    def __neg__(self) -> bvec1: ...
    def __pos__(self) -> bvec1: ...
    def __abs__(self) -> bvec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[bool]: ...
    def to_tuple(self) -> Tuple[bool]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> bvec1: ...

    def __add__(self, other: Union[glm_typing.B8Vector1, glm_typing.Number]) -> bvec1: ...
    def __iadd__(self, other: Union[glm_typing.B8Vector1, glm_typing.Number]) -> bvec1: ...

    def __sub__(self, other: Union[glm_typing.B8Vector1, glm_typing.Number]) -> bvec1: ...
    def __isub__(self, other: Union[glm_typing.B8Vector1, glm_typing.Number]) -> bvec1: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> bvec1: ...
    @overload
    def __mul__(self, other: glm_typing.B8Vector1) -> bvec1: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> bvec1: ...
    @overload
    def __imul__(self, other: glm_typing.B8Vector1) -> bvec1: ...

    def __mod__(self, other: Union[glm_typing.B8Vector1, glm_typing.Number]) -> bvec1: ...
    def __imod__(self, other: Union[glm_typing.B8Vector1, glm_typing.Number]) -> bvec1: ...

    def __pow__(self, other: Union[glm_typing.B8Vector1, glm_typing.Number]) -> bvec1: ...
    def __ipow__(self, other: Union[glm_typing.B8Vector1, glm_typing.Number]) -> bvec1: ...

    def __floordiv__(self, other: Union[glm_typing.B8Vector1, glm_typing.Number]) -> bvec1: ...
    def __ifloordiv__(self, other: Union[glm_typing.B8Vector1, glm_typing.Number]) -> bvec1: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> bvec1: ...
    @overload
    def __matmul__(self, other: glm_typing.B8Vector1) -> bvec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> bvec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.B8Vector1) -> bvec1: ...

    def __divmod__(self, other: bvec1) -> Tuple[bvec1, bvec1]: ...



class bvec2:
    x: bool
    y: bool

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.BAnyVector3, glm_typing.BAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[bool, None, None]: ...

    def __neg__(self) -> bvec2: ...
    def __pos__(self) -> bvec2: ...
    def __abs__(self) -> bvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[bool]: ...
    def to_tuple(self) -> Tuple[bool, bool]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> bvec2: ...

    def __add__(self, other: Union[glm_typing.B8Vector2, glm_typing.Number]) -> bvec2: ...
    def __iadd__(self, other: Union[glm_typing.B8Vector2, glm_typing.Number]) -> bvec2: ...

    def __sub__(self, other: Union[glm_typing.B8Vector2, glm_typing.Number]) -> bvec2: ...
    def __isub__(self, other: Union[glm_typing.B8Vector2, glm_typing.Number]) -> bvec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> bvec2: ...
    @overload
    def __mul__(self, other: glm_typing.B8Vector2) -> bvec2: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> bvec2: ...
    @overload
    def __imul__(self, other: glm_typing.B8Vector2) -> bvec2: ...

    def __mod__(self, other: Union[glm_typing.B8Vector2, glm_typing.Number]) -> bvec2: ...
    def __imod__(self, other: Union[glm_typing.B8Vector2, glm_typing.Number]) -> bvec2: ...

    def __pow__(self, other: Union[glm_typing.B8Vector2, glm_typing.Number]) -> bvec2: ...
    def __ipow__(self, other: Union[glm_typing.B8Vector2, glm_typing.Number]) -> bvec2: ...

    def __floordiv__(self, other: Union[glm_typing.B8Vector2, glm_typing.Number]) -> bvec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.B8Vector2, glm_typing.Number]) -> bvec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> bvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.B8Vector2) -> bvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> bvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.B8Vector2) -> bvec2: ...

    def __divmod__(self, other: bvec2) -> Tuple[bvec2, bvec2]: ...



class bvec3:
    x: bool
    y: bool
    z: bool

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.BAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[bool, None, None]: ...

    def __neg__(self) -> bvec3: ...
    def __pos__(self) -> bvec3: ...
    def __abs__(self) -> bvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[bool]: ...
    def to_tuple(self) -> Tuple[bool, bool, bool]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> bvec3: ...

    def __add__(self, other: Union[glm_typing.B8Vector3, glm_typing.Number]) -> bvec3: ...
    def __iadd__(self, other: Union[glm_typing.B8Vector3, glm_typing.Number]) -> bvec3: ...

    def __sub__(self, other: Union[glm_typing.B8Vector3, glm_typing.Number]) -> bvec3: ...
    def __isub__(self, other: Union[glm_typing.B8Vector3, glm_typing.Number]) -> bvec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> bvec3: ...
    @overload
    def __mul__(self, other: glm_typing.B8Vector3) -> bvec3: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> bvec3: ...
    @overload
    def __imul__(self, other: glm_typing.B8Vector3) -> bvec3: ...

    def __mod__(self, other: Union[glm_typing.B8Vector3, glm_typing.Number]) -> bvec3: ...
    def __imod__(self, other: Union[glm_typing.B8Vector3, glm_typing.Number]) -> bvec3: ...

    def __pow__(self, other: Union[glm_typing.B8Vector3, glm_typing.Number]) -> bvec3: ...
    def __ipow__(self, other: Union[glm_typing.B8Vector3, glm_typing.Number]) -> bvec3: ...

    def __floordiv__(self, other: Union[glm_typing.B8Vector3, glm_typing.Number]) -> bvec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.B8Vector3, glm_typing.Number]) -> bvec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> bvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.B8Vector3) -> bvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> bvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.B8Vector3) -> bvec3: ...

    def __divmod__(self, other: bvec3) -> Tuple[bvec3, bvec3]: ...



class bvec4:
    x: bool
    y: bool
    z: bool
    w: bool

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[bool, None, None]: ...

    def __neg__(self) -> bvec4: ...
    def __pos__(self) -> bvec4: ...
    def __abs__(self) -> bvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[bool]: ...
    def to_tuple(self) -> Tuple[bool, bool, bool, bool]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> bvec4: ...

    def __add__(self, other: Union[glm_typing.B8Vector4, glm_typing.Number]) -> bvec4: ...
    def __iadd__(self, other: Union[glm_typing.B8Vector4, glm_typing.Number]) -> bvec4: ...

    def __sub__(self, other: Union[glm_typing.B8Vector4, glm_typing.Number]) -> bvec4: ...
    def __isub__(self, other: Union[glm_typing.B8Vector4, glm_typing.Number]) -> bvec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> bvec4: ...
    @overload
    def __mul__(self, other: glm_typing.B8Vector4) -> bvec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> bvec4: ...
    @overload
    def __imul__(self, other: glm_typing.B8Vector4) -> bvec4: ...

    def __mod__(self, other: Union[glm_typing.B8Vector4, glm_typing.Number]) -> bvec4: ...
    def __imod__(self, other: Union[glm_typing.B8Vector4, glm_typing.Number]) -> bvec4: ...

    def __pow__(self, other: Union[glm_typing.B8Vector4, glm_typing.Number]) -> bvec4: ...
    def __ipow__(self, other: Union[glm_typing.B8Vector4, glm_typing.Number]) -> bvec4: ...

    def __floordiv__(self, other: Union[glm_typing.B8Vector4, glm_typing.Number]) -> bvec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.B8Vector4, glm_typing.Number]) -> bvec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> bvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.B8Vector4) -> bvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> bvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.B8Vector4) -> bvec4: ...

    def __divmod__(self, other: bvec4) -> Tuple[bvec4, bvec4]: ...



class dmvec2:
    x: float
    y: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.DAnyVector3, glm_typing.DAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dmvec2: ...
    def __pos__(self) -> dmvec2: ...
    def __abs__(self) -> dmvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmvec2: ...

    def __add__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dmvec2: ...
    def __iadd__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dmvec2: ...

    def __sub__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dmvec2: ...
    def __isub__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dmvec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> dmvec2: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector2) -> dmvec2: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> dmvec2: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector2) -> dmvec2: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dmvec2: ...
    def __imod__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dmvec2: ...

    def __pow__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dmvec2: ...
    def __ipow__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dmvec2: ...

    def __floordiv__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dmvec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dmvec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> dmvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector2) -> dmvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> dmvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector2) -> dmvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __divmod__(self, other: dmvec2) -> Tuple[dmvec2, dmvec2]: ...



class dmvec3:
    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.DAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dmvec3: ...
    def __pos__(self) -> dmvec3: ...
    def __abs__(self) -> dmvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmvec3: ...

    def __add__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dmvec3: ...
    def __iadd__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dmvec3: ...

    def __sub__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dmvec3: ...
    def __isub__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dmvec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> dmvec3: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector3) -> dmvec3: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> dmvec3: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector3) -> dmvec3: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dmvec3: ...
    def __imod__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dmvec3: ...

    def __pow__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dmvec3: ...
    def __ipow__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dmvec3: ...

    def __floordiv__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dmvec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dmvec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> dmvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector3) -> dmvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> dmvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector3) -> dmvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __divmod__(self, other: dmvec3) -> Tuple[dmvec3, dmvec3]: ...



class dmvec4:
    x: float
    y: float
    z: float
    w: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dmvec4: ...
    def __pos__(self) -> dmvec4: ...
    def __abs__(self) -> dmvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmvec4: ...

    def __add__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dmvec4: ...
    def __iadd__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dmvec4: ...

    def __sub__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dmvec4: ...
    def __isub__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dmvec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> dmvec4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector4) -> dmvec4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> dmvec4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector4) -> dmvec4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dmvec4: ...
    def __imod__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dmvec4: ...

    def __pow__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dmvec4: ...
    def __ipow__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dmvec4: ...

    def __floordiv__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dmvec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dmvec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> dmvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector4) -> dmvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> dmvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector4) -> dmvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __divmod__(self, other: dmvec4) -> Tuple[dmvec4, dmvec4]: ...


f64vec1 = dvec1

class dvec1:
    x: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector1, glm_typing.DAnyVector2, glm_typing.DAnyVector3, glm_typing.DAnyVector4]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dvec1: ...
    def __pos__(self) -> dvec1: ...
    def __abs__(self) -> dvec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dvec1: ...

    def __add__(self, other: Union[glm_typing.D64Vector1, glm_typing.Number]) -> dvec1: ...
    def __iadd__(self, other: Union[glm_typing.D64Vector1, glm_typing.Number]) -> dvec1: ...

    def __sub__(self, other: Union[glm_typing.D64Vector1, glm_typing.Number]) -> dvec1: ...
    def __isub__(self, other: Union[glm_typing.D64Vector1, glm_typing.Number]) -> dvec1: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> dvec1: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector1) -> dvec1: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> dvec1: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector1) -> dvec1: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.D64Vector1, glm_typing.Number]) -> dvec1: ...
    def __imod__(self, other: Union[glm_typing.D64Vector1, glm_typing.Number]) -> dvec1: ...

    def __pow__(self, other: Union[glm_typing.D64Vector1, glm_typing.Number]) -> dvec1: ...
    def __ipow__(self, other: Union[glm_typing.D64Vector1, glm_typing.Number]) -> dvec1: ...

    def __floordiv__(self, other: Union[glm_typing.D64Vector1, glm_typing.Number]) -> dvec1: ...
    def __ifloordiv__(self, other: Union[glm_typing.D64Vector1, glm_typing.Number]) -> dvec1: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> dvec1: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector1) -> dvec1: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> dvec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector1) -> dvec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __divmod__(self, other: dvec1) -> Tuple[dvec1, dvec1]: ...


f64vec2 = dvec2

class dvec2:
    x: float
    y: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.DAnyVector3, glm_typing.DAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dvec2: ...
    def __pos__(self) -> dvec2: ...
    def __abs__(self) -> dvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dvec2: ...

    def __add__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dvec2: ...
    def __iadd__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dvec2: ...

    def __sub__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dvec2: ...
    def __isub__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dvec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> dvec2: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector2) -> dvec2: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> dvec2: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector2) -> dvec2: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dvec2: ...
    def __imod__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dvec2: ...

    def __pow__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dvec2: ...
    def __ipow__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dvec2: ...

    def __floordiv__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dvec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.D64Vector2, glm_typing.Number]) -> dvec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> dvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector2) -> dvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> dvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector2) -> dvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __divmod__(self, other: dvec2) -> Tuple[dvec2, dvec2]: ...


f64vec3 = dvec3

class dvec3:
    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.DAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dvec3: ...
    def __pos__(self) -> dvec3: ...
    def __abs__(self) -> dvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dvec3: ...

    def __add__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dvec3: ...
    def __iadd__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dvec3: ...

    def __sub__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dvec3: ...
    def __isub__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dvec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> dvec3: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> dvec3: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dvec3: ...
    def __imod__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dvec3: ...

    def __pow__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dvec3: ...
    def __ipow__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dvec3: ...

    def __floordiv__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dvec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.D64Vector3, glm_typing.Number]) -> dvec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> dvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> dvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __divmod__(self, other: dvec3) -> Tuple[dvec3, dvec3]: ...


f64vec4 = dvec4

class dvec4:
    x: float
    y: float
    z: float
    w: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dvec4: ...
    def __pos__(self) -> dvec4: ...
    def __abs__(self) -> dvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dvec4: ...

    def __add__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dvec4: ...
    def __iadd__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dvec4: ...

    def __sub__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dvec4: ...
    def __isub__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dvec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> dvec4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector4) -> dvec4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> dvec4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector4) -> dvec4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dvec4: ...
    def __imod__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dvec4: ...

    def __pow__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dvec4: ...
    def __ipow__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dvec4: ...

    def __floordiv__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dvec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.D64Vector4, glm_typing.Number]) -> dvec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> dvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector4) -> dvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> dvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector4) -> dvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Matrix4x2) -> vec4: ...

    def __divmod__(self, other: dvec4) -> Tuple[dvec4, dvec4]: ...



class i16vec1:
    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector1, glm_typing.IAnyVector2, glm_typing.IAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i16vec1: ...
    def __pos__(self) -> i16vec1: ...
    def __abs__(self) -> i16vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i16vec1: ...

    def __add__(self, other: Union[glm_typing.I16Vector1, glm_typing.Number]) -> i16vec1: ...
    def __iadd__(self, other: Union[glm_typing.I16Vector1, glm_typing.Number]) -> i16vec1: ...

    def __sub__(self, other: Union[glm_typing.I16Vector1, glm_typing.Number]) -> i16vec1: ...
    def __isub__(self, other: Union[glm_typing.I16Vector1, glm_typing.Number]) -> i16vec1: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> i16vec1: ...
    @overload
    def __mul__(self, other: glm_typing.I16Vector1) -> i16vec1: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> i16vec1: ...
    @overload
    def __imul__(self, other: glm_typing.I16Vector1) -> i16vec1: ...

    def __mod__(self, other: Union[glm_typing.I16Vector1, glm_typing.Number]) -> i16vec1: ...
    def __imod__(self, other: Union[glm_typing.I16Vector1, glm_typing.Number]) -> i16vec1: ...

    def __pow__(self, other: Union[glm_typing.I16Vector1, glm_typing.Number]) -> i16vec1: ...
    def __ipow__(self, other: Union[glm_typing.I16Vector1, glm_typing.Number]) -> i16vec1: ...

    def __floordiv__(self, other: Union[glm_typing.I16Vector1, glm_typing.Number]) -> i16vec1: ...
    def __ifloordiv__(self, other: Union[glm_typing.I16Vector1, glm_typing.Number]) -> i16vec1: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> i16vec1: ...
    @overload
    def __matmul__(self, other: glm_typing.I16Vector1) -> i16vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> i16vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.I16Vector1) -> i16vec1: ...

    def __divmod__(self, other: i16vec1) -> Tuple[i16vec1, i16vec1]: ...



class i16vec2:
    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.IAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i16vec2: ...
    def __pos__(self) -> i16vec2: ...
    def __abs__(self) -> i16vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i16vec2: ...

    def __add__(self, other: Union[glm_typing.I16Vector2, glm_typing.Number]) -> i16vec2: ...
    def __iadd__(self, other: Union[glm_typing.I16Vector2, glm_typing.Number]) -> i16vec2: ...

    def __sub__(self, other: Union[glm_typing.I16Vector2, glm_typing.Number]) -> i16vec2: ...
    def __isub__(self, other: Union[glm_typing.I16Vector2, glm_typing.Number]) -> i16vec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> i16vec2: ...
    @overload
    def __mul__(self, other: glm_typing.I16Vector2) -> i16vec2: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> i16vec2: ...
    @overload
    def __imul__(self, other: glm_typing.I16Vector2) -> i16vec2: ...

    def __mod__(self, other: Union[glm_typing.I16Vector2, glm_typing.Number]) -> i16vec2: ...
    def __imod__(self, other: Union[glm_typing.I16Vector2, glm_typing.Number]) -> i16vec2: ...

    def __pow__(self, other: Union[glm_typing.I16Vector2, glm_typing.Number]) -> i16vec2: ...
    def __ipow__(self, other: Union[glm_typing.I16Vector2, glm_typing.Number]) -> i16vec2: ...

    def __floordiv__(self, other: Union[glm_typing.I16Vector2, glm_typing.Number]) -> i16vec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.I16Vector2, glm_typing.Number]) -> i16vec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> i16vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I16Vector2) -> i16vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> i16vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I16Vector2) -> i16vec2: ...

    def __divmod__(self, other: i16vec2) -> Tuple[i16vec2, i16vec2]: ...



class i16vec3:
    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i16vec3: ...
    def __pos__(self) -> i16vec3: ...
    def __abs__(self) -> i16vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i16vec3: ...

    def __add__(self, other: Union[glm_typing.I16Vector3, glm_typing.Number]) -> i16vec3: ...
    def __iadd__(self, other: Union[glm_typing.I16Vector3, glm_typing.Number]) -> i16vec3: ...

    def __sub__(self, other: Union[glm_typing.I16Vector3, glm_typing.Number]) -> i16vec3: ...
    def __isub__(self, other: Union[glm_typing.I16Vector3, glm_typing.Number]) -> i16vec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> i16vec3: ...
    @overload
    def __mul__(self, other: glm_typing.I16Vector3) -> i16vec3: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> i16vec3: ...
    @overload
    def __imul__(self, other: glm_typing.I16Vector3) -> i16vec3: ...

    def __mod__(self, other: Union[glm_typing.I16Vector3, glm_typing.Number]) -> i16vec3: ...
    def __imod__(self, other: Union[glm_typing.I16Vector3, glm_typing.Number]) -> i16vec3: ...

    def __pow__(self, other: Union[glm_typing.I16Vector3, glm_typing.Number]) -> i16vec3: ...
    def __ipow__(self, other: Union[glm_typing.I16Vector3, glm_typing.Number]) -> i16vec3: ...

    def __floordiv__(self, other: Union[glm_typing.I16Vector3, glm_typing.Number]) -> i16vec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.I16Vector3, glm_typing.Number]) -> i16vec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> i16vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I16Vector3) -> i16vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> i16vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I16Vector3) -> i16vec3: ...

    def __divmod__(self, other: i16vec3) -> Tuple[i16vec3, i16vec3]: ...



class i16vec4:
    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i16vec4: ...
    def __pos__(self) -> i16vec4: ...
    def __abs__(self) -> i16vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i16vec4: ...

    def __add__(self, other: Union[glm_typing.I16Vector4, glm_typing.Number]) -> i16vec4: ...
    def __iadd__(self, other: Union[glm_typing.I16Vector4, glm_typing.Number]) -> i16vec4: ...

    def __sub__(self, other: Union[glm_typing.I16Vector4, glm_typing.Number]) -> i16vec4: ...
    def __isub__(self, other: Union[glm_typing.I16Vector4, glm_typing.Number]) -> i16vec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> i16vec4: ...
    @overload
    def __mul__(self, other: glm_typing.I16Vector4) -> i16vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> i16vec4: ...
    @overload
    def __imul__(self, other: glm_typing.I16Vector4) -> i16vec4: ...

    def __mod__(self, other: Union[glm_typing.I16Vector4, glm_typing.Number]) -> i16vec4: ...
    def __imod__(self, other: Union[glm_typing.I16Vector4, glm_typing.Number]) -> i16vec4: ...

    def __pow__(self, other: Union[glm_typing.I16Vector4, glm_typing.Number]) -> i16vec4: ...
    def __ipow__(self, other: Union[glm_typing.I16Vector4, glm_typing.Number]) -> i16vec4: ...

    def __floordiv__(self, other: Union[glm_typing.I16Vector4, glm_typing.Number]) -> i16vec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.I16Vector4, glm_typing.Number]) -> i16vec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> i16vec4: ...
    @overload
    def __matmul__(self, other: glm_typing.I16Vector4) -> i16vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> i16vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I16Vector4) -> i16vec4: ...

    def __divmod__(self, other: i16vec4) -> Tuple[i16vec4, i16vec4]: ...



class i64vec1:
    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector1, glm_typing.IAnyVector2, glm_typing.IAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i64vec1: ...
    def __pos__(self) -> i64vec1: ...
    def __abs__(self) -> i64vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i64vec1: ...

    def __add__(self, other: Union[glm_typing.I64Vector1, glm_typing.Number]) -> i64vec1: ...
    def __iadd__(self, other: Union[glm_typing.I64Vector1, glm_typing.Number]) -> i64vec1: ...

    def __sub__(self, other: Union[glm_typing.I64Vector1, glm_typing.Number]) -> i64vec1: ...
    def __isub__(self, other: Union[glm_typing.I64Vector1, glm_typing.Number]) -> i64vec1: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> i64vec1: ...
    @overload
    def __mul__(self, other: glm_typing.I64Vector1) -> i64vec1: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> i64vec1: ...
    @overload
    def __imul__(self, other: glm_typing.I64Vector1) -> i64vec1: ...

    def __mod__(self, other: Union[glm_typing.I64Vector1, glm_typing.Number]) -> i64vec1: ...
    def __imod__(self, other: Union[glm_typing.I64Vector1, glm_typing.Number]) -> i64vec1: ...

    def __pow__(self, other: Union[glm_typing.I64Vector1, glm_typing.Number]) -> i64vec1: ...
    def __ipow__(self, other: Union[glm_typing.I64Vector1, glm_typing.Number]) -> i64vec1: ...

    def __floordiv__(self, other: Union[glm_typing.I64Vector1, glm_typing.Number]) -> i64vec1: ...
    def __ifloordiv__(self, other: Union[glm_typing.I64Vector1, glm_typing.Number]) -> i64vec1: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> i64vec1: ...
    @overload
    def __matmul__(self, other: glm_typing.I64Vector1) -> i64vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> i64vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.I64Vector1) -> i64vec1: ...

    def __divmod__(self, other: i64vec1) -> Tuple[i64vec1, i64vec1]: ...



class i64vec2:
    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.IAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i64vec2: ...
    def __pos__(self) -> i64vec2: ...
    def __abs__(self) -> i64vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i64vec2: ...

    def __add__(self, other: Union[glm_typing.I64Vector2, glm_typing.Number]) -> i64vec2: ...
    def __iadd__(self, other: Union[glm_typing.I64Vector2, glm_typing.Number]) -> i64vec2: ...

    def __sub__(self, other: Union[glm_typing.I64Vector2, glm_typing.Number]) -> i64vec2: ...
    def __isub__(self, other: Union[glm_typing.I64Vector2, glm_typing.Number]) -> i64vec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> i64vec2: ...
    @overload
    def __mul__(self, other: glm_typing.I64Vector2) -> i64vec2: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> i64vec2: ...
    @overload
    def __imul__(self, other: glm_typing.I64Vector2) -> i64vec2: ...

    def __mod__(self, other: Union[glm_typing.I64Vector2, glm_typing.Number]) -> i64vec2: ...
    def __imod__(self, other: Union[glm_typing.I64Vector2, glm_typing.Number]) -> i64vec2: ...

    def __pow__(self, other: Union[glm_typing.I64Vector2, glm_typing.Number]) -> i64vec2: ...
    def __ipow__(self, other: Union[glm_typing.I64Vector2, glm_typing.Number]) -> i64vec2: ...

    def __floordiv__(self, other: Union[glm_typing.I64Vector2, glm_typing.Number]) -> i64vec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.I64Vector2, glm_typing.Number]) -> i64vec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> i64vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I64Vector2) -> i64vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> i64vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I64Vector2) -> i64vec2: ...

    def __divmod__(self, other: i64vec2) -> Tuple[i64vec2, i64vec2]: ...



class i64vec3:
    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i64vec3: ...
    def __pos__(self) -> i64vec3: ...
    def __abs__(self) -> i64vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i64vec3: ...

    def __add__(self, other: Union[glm_typing.I64Vector3, glm_typing.Number]) -> i64vec3: ...
    def __iadd__(self, other: Union[glm_typing.I64Vector3, glm_typing.Number]) -> i64vec3: ...

    def __sub__(self, other: Union[glm_typing.I64Vector3, glm_typing.Number]) -> i64vec3: ...
    def __isub__(self, other: Union[glm_typing.I64Vector3, glm_typing.Number]) -> i64vec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> i64vec3: ...
    @overload
    def __mul__(self, other: glm_typing.I64Vector3) -> i64vec3: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> i64vec3: ...
    @overload
    def __imul__(self, other: glm_typing.I64Vector3) -> i64vec3: ...

    def __mod__(self, other: Union[glm_typing.I64Vector3, glm_typing.Number]) -> i64vec3: ...
    def __imod__(self, other: Union[glm_typing.I64Vector3, glm_typing.Number]) -> i64vec3: ...

    def __pow__(self, other: Union[glm_typing.I64Vector3, glm_typing.Number]) -> i64vec3: ...
    def __ipow__(self, other: Union[glm_typing.I64Vector3, glm_typing.Number]) -> i64vec3: ...

    def __floordiv__(self, other: Union[glm_typing.I64Vector3, glm_typing.Number]) -> i64vec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.I64Vector3, glm_typing.Number]) -> i64vec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> i64vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I64Vector3) -> i64vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> i64vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I64Vector3) -> i64vec3: ...

    def __divmod__(self, other: i64vec3) -> Tuple[i64vec3, i64vec3]: ...



class i64vec4:
    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i64vec4: ...
    def __pos__(self) -> i64vec4: ...
    def __abs__(self) -> i64vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i64vec4: ...

    def __add__(self, other: Union[glm_typing.I64Vector4, glm_typing.Number]) -> i64vec4: ...
    def __iadd__(self, other: Union[glm_typing.I64Vector4, glm_typing.Number]) -> i64vec4: ...

    def __sub__(self, other: Union[glm_typing.I64Vector4, glm_typing.Number]) -> i64vec4: ...
    def __isub__(self, other: Union[glm_typing.I64Vector4, glm_typing.Number]) -> i64vec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> i64vec4: ...
    @overload
    def __mul__(self, other: glm_typing.I64Vector4) -> i64vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> i64vec4: ...
    @overload
    def __imul__(self, other: glm_typing.I64Vector4) -> i64vec4: ...

    def __mod__(self, other: Union[glm_typing.I64Vector4, glm_typing.Number]) -> i64vec4: ...
    def __imod__(self, other: Union[glm_typing.I64Vector4, glm_typing.Number]) -> i64vec4: ...

    def __pow__(self, other: Union[glm_typing.I64Vector4, glm_typing.Number]) -> i64vec4: ...
    def __ipow__(self, other: Union[glm_typing.I64Vector4, glm_typing.Number]) -> i64vec4: ...

    def __floordiv__(self, other: Union[glm_typing.I64Vector4, glm_typing.Number]) -> i64vec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.I64Vector4, glm_typing.Number]) -> i64vec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> i64vec4: ...
    @overload
    def __matmul__(self, other: glm_typing.I64Vector4) -> i64vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> i64vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I64Vector4) -> i64vec4: ...

    def __divmod__(self, other: i64vec4) -> Tuple[i64vec4, i64vec4]: ...



class i8vec1:
    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector1, glm_typing.IAnyVector2, glm_typing.IAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i8vec1: ...
    def __pos__(self) -> i8vec1: ...
    def __abs__(self) -> i8vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i8vec1: ...

    def __add__(self, other: Union[glm_typing.I8Vector1, glm_typing.Number]) -> i8vec1: ...
    def __iadd__(self, other: Union[glm_typing.I8Vector1, glm_typing.Number]) -> i8vec1: ...

    def __sub__(self, other: Union[glm_typing.I8Vector1, glm_typing.Number]) -> i8vec1: ...
    def __isub__(self, other: Union[glm_typing.I8Vector1, glm_typing.Number]) -> i8vec1: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> i8vec1: ...
    @overload
    def __mul__(self, other: glm_typing.I8Vector1) -> i8vec1: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> i8vec1: ...
    @overload
    def __imul__(self, other: glm_typing.I8Vector1) -> i8vec1: ...

    def __mod__(self, other: Union[glm_typing.I8Vector1, glm_typing.Number]) -> i8vec1: ...
    def __imod__(self, other: Union[glm_typing.I8Vector1, glm_typing.Number]) -> i8vec1: ...

    def __pow__(self, other: Union[glm_typing.I8Vector1, glm_typing.Number]) -> i8vec1: ...
    def __ipow__(self, other: Union[glm_typing.I8Vector1, glm_typing.Number]) -> i8vec1: ...

    def __floordiv__(self, other: Union[glm_typing.I8Vector1, glm_typing.Number]) -> i8vec1: ...
    def __ifloordiv__(self, other: Union[glm_typing.I8Vector1, glm_typing.Number]) -> i8vec1: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> i8vec1: ...
    @overload
    def __matmul__(self, other: glm_typing.I8Vector1) -> i8vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> i8vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.I8Vector1) -> i8vec1: ...

    def __divmod__(self, other: i8vec1) -> Tuple[i8vec1, i8vec1]: ...



class i8vec2:
    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.IAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i8vec2: ...
    def __pos__(self) -> i8vec2: ...
    def __abs__(self) -> i8vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i8vec2: ...

    def __add__(self, other: Union[glm_typing.I8Vector2, glm_typing.Number]) -> i8vec2: ...
    def __iadd__(self, other: Union[glm_typing.I8Vector2, glm_typing.Number]) -> i8vec2: ...

    def __sub__(self, other: Union[glm_typing.I8Vector2, glm_typing.Number]) -> i8vec2: ...
    def __isub__(self, other: Union[glm_typing.I8Vector2, glm_typing.Number]) -> i8vec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> i8vec2: ...
    @overload
    def __mul__(self, other: glm_typing.I8Vector2) -> i8vec2: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> i8vec2: ...
    @overload
    def __imul__(self, other: glm_typing.I8Vector2) -> i8vec2: ...

    def __mod__(self, other: Union[glm_typing.I8Vector2, glm_typing.Number]) -> i8vec2: ...
    def __imod__(self, other: Union[glm_typing.I8Vector2, glm_typing.Number]) -> i8vec2: ...

    def __pow__(self, other: Union[glm_typing.I8Vector2, glm_typing.Number]) -> i8vec2: ...
    def __ipow__(self, other: Union[glm_typing.I8Vector2, glm_typing.Number]) -> i8vec2: ...

    def __floordiv__(self, other: Union[glm_typing.I8Vector2, glm_typing.Number]) -> i8vec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.I8Vector2, glm_typing.Number]) -> i8vec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> i8vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I8Vector2) -> i8vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> i8vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I8Vector2) -> i8vec2: ...

    def __divmod__(self, other: i8vec2) -> Tuple[i8vec2, i8vec2]: ...



class i8vec3:
    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i8vec3: ...
    def __pos__(self) -> i8vec3: ...
    def __abs__(self) -> i8vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i8vec3: ...

    def __add__(self, other: Union[glm_typing.I8Vector3, glm_typing.Number]) -> i8vec3: ...
    def __iadd__(self, other: Union[glm_typing.I8Vector3, glm_typing.Number]) -> i8vec3: ...

    def __sub__(self, other: Union[glm_typing.I8Vector3, glm_typing.Number]) -> i8vec3: ...
    def __isub__(self, other: Union[glm_typing.I8Vector3, glm_typing.Number]) -> i8vec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> i8vec3: ...
    @overload
    def __mul__(self, other: glm_typing.I8Vector3) -> i8vec3: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> i8vec3: ...
    @overload
    def __imul__(self, other: glm_typing.I8Vector3) -> i8vec3: ...

    def __mod__(self, other: Union[glm_typing.I8Vector3, glm_typing.Number]) -> i8vec3: ...
    def __imod__(self, other: Union[glm_typing.I8Vector3, glm_typing.Number]) -> i8vec3: ...

    def __pow__(self, other: Union[glm_typing.I8Vector3, glm_typing.Number]) -> i8vec3: ...
    def __ipow__(self, other: Union[glm_typing.I8Vector3, glm_typing.Number]) -> i8vec3: ...

    def __floordiv__(self, other: Union[glm_typing.I8Vector3, glm_typing.Number]) -> i8vec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.I8Vector3, glm_typing.Number]) -> i8vec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> i8vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I8Vector3) -> i8vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> i8vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I8Vector3) -> i8vec3: ...

    def __divmod__(self, other: i8vec3) -> Tuple[i8vec3, i8vec3]: ...



class i8vec4:
    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i8vec4: ...
    def __pos__(self) -> i8vec4: ...
    def __abs__(self) -> i8vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i8vec4: ...

    def __add__(self, other: Union[glm_typing.I8Vector4, glm_typing.Number]) -> i8vec4: ...
    def __iadd__(self, other: Union[glm_typing.I8Vector4, glm_typing.Number]) -> i8vec4: ...

    def __sub__(self, other: Union[glm_typing.I8Vector4, glm_typing.Number]) -> i8vec4: ...
    def __isub__(self, other: Union[glm_typing.I8Vector4, glm_typing.Number]) -> i8vec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> i8vec4: ...
    @overload
    def __mul__(self, other: glm_typing.I8Vector4) -> i8vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> i8vec4: ...
    @overload
    def __imul__(self, other: glm_typing.I8Vector4) -> i8vec4: ...

    def __mod__(self, other: Union[glm_typing.I8Vector4, glm_typing.Number]) -> i8vec4: ...
    def __imod__(self, other: Union[glm_typing.I8Vector4, glm_typing.Number]) -> i8vec4: ...

    def __pow__(self, other: Union[glm_typing.I8Vector4, glm_typing.Number]) -> i8vec4: ...
    def __ipow__(self, other: Union[glm_typing.I8Vector4, glm_typing.Number]) -> i8vec4: ...

    def __floordiv__(self, other: Union[glm_typing.I8Vector4, glm_typing.Number]) -> i8vec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.I8Vector4, glm_typing.Number]) -> i8vec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> i8vec4: ...
    @overload
    def __matmul__(self, other: glm_typing.I8Vector4) -> i8vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> i8vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I8Vector4) -> i8vec4: ...

    def __divmod__(self, other: i8vec4) -> Tuple[i8vec4, i8vec4]: ...



class imvec2:
    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.IAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> imvec2: ...
    def __pos__(self) -> imvec2: ...
    def __abs__(self) -> imvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imvec2: ...

    def __add__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> imvec2: ...
    def __iadd__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> imvec2: ...

    def __sub__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> imvec2: ...
    def __isub__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> imvec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> imvec2: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector2) -> imvec2: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> imvec2: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector2) -> imvec2: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> imvec2: ...
    def __imod__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> imvec2: ...

    def __pow__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> imvec2: ...
    def __ipow__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> imvec2: ...

    def __floordiv__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> imvec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> imvec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> imvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector2) -> imvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> imvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector2) -> imvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: imvec2) -> Tuple[imvec2, imvec2]: ...



class imvec3:
    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> imvec3: ...
    def __pos__(self) -> imvec3: ...
    def __abs__(self) -> imvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imvec3: ...

    def __add__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> imvec3: ...
    def __iadd__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> imvec3: ...

    def __sub__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> imvec3: ...
    def __isub__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> imvec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> imvec3: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector3) -> imvec3: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> imvec3: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector3) -> imvec3: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> imvec3: ...
    def __imod__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> imvec3: ...

    def __pow__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> imvec3: ...
    def __ipow__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> imvec3: ...

    def __floordiv__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> imvec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> imvec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> imvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector3) -> imvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> imvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector3) -> imvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: imvec3) -> Tuple[imvec3, imvec3]: ...



class imvec4:
    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> imvec4: ...
    def __pos__(self) -> imvec4: ...
    def __abs__(self) -> imvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imvec4: ...

    def __add__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> imvec4: ...
    def __iadd__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> imvec4: ...

    def __sub__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> imvec4: ...
    def __isub__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> imvec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> imvec4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector4) -> imvec4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> imvec4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector4) -> imvec4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> imvec4: ...
    def __imod__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> imvec4: ...

    def __pow__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> imvec4: ...
    def __ipow__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> imvec4: ...

    def __floordiv__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> imvec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> imvec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> imvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector4) -> imvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> imvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector4) -> imvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: imvec4) -> Tuple[imvec4, imvec4]: ...


i32vec1 = ivec1

class ivec1:
    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector1, glm_typing.IAnyVector2, glm_typing.IAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> ivec1: ...
    def __pos__(self) -> ivec1: ...
    def __abs__(self) -> ivec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> ivec1: ...

    def __add__(self, other: Union[glm_typing.I32Vector1, glm_typing.Number]) -> ivec1: ...
    def __iadd__(self, other: Union[glm_typing.I32Vector1, glm_typing.Number]) -> ivec1: ...

    def __sub__(self, other: Union[glm_typing.I32Vector1, glm_typing.Number]) -> ivec1: ...
    def __isub__(self, other: Union[glm_typing.I32Vector1, glm_typing.Number]) -> ivec1: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> ivec1: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector1) -> ivec1: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> ivec1: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector1) -> ivec1: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.I32Vector1, glm_typing.Number]) -> ivec1: ...
    def __imod__(self, other: Union[glm_typing.I32Vector1, glm_typing.Number]) -> ivec1: ...

    def __pow__(self, other: Union[glm_typing.I32Vector1, glm_typing.Number]) -> ivec1: ...
    def __ipow__(self, other: Union[glm_typing.I32Vector1, glm_typing.Number]) -> ivec1: ...

    def __floordiv__(self, other: Union[glm_typing.I32Vector1, glm_typing.Number]) -> ivec1: ...
    def __ifloordiv__(self, other: Union[glm_typing.I32Vector1, glm_typing.Number]) -> ivec1: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> ivec1: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector1) -> ivec1: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> ivec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector1) -> ivec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: ivec1) -> Tuple[ivec1, ivec1]: ...


i32vec2 = ivec2

class ivec2:
    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.IAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> ivec2: ...
    def __pos__(self) -> ivec2: ...
    def __abs__(self) -> ivec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> ivec2: ...

    def __add__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> ivec2: ...
    def __iadd__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> ivec2: ...

    def __sub__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> ivec2: ...
    def __isub__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> ivec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> ivec2: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector2) -> ivec2: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> ivec2: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector2) -> ivec2: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> ivec2: ...
    def __imod__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> ivec2: ...

    def __pow__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> ivec2: ...
    def __ipow__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> ivec2: ...

    def __floordiv__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> ivec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.I32Vector2, glm_typing.Number]) -> ivec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> ivec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector2) -> ivec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> ivec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector2) -> ivec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: ivec2) -> Tuple[ivec2, ivec2]: ...


i32vec3 = ivec3

class ivec3:
    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.IAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> ivec3: ...
    def __pos__(self) -> ivec3: ...
    def __abs__(self) -> ivec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> ivec3: ...

    def __add__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> ivec3: ...
    def __iadd__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> ivec3: ...

    def __sub__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> ivec3: ...
    def __isub__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> ivec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> ivec3: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector3) -> ivec3: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> ivec3: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector3) -> ivec3: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> ivec3: ...
    def __imod__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> ivec3: ...

    def __pow__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> ivec3: ...
    def __ipow__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> ivec3: ...

    def __floordiv__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> ivec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.I32Vector3, glm_typing.Number]) -> ivec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> ivec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector3) -> ivec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> ivec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector3) -> ivec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: ivec3) -> Tuple[ivec3, ivec3]: ...


i32vec4 = ivec4

class ivec4:
    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> ivec4: ...
    def __pos__(self) -> ivec4: ...
    def __abs__(self) -> ivec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> ivec4: ...

    def __add__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> ivec4: ...
    def __iadd__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> ivec4: ...

    def __sub__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> ivec4: ...
    def __isub__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> ivec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> ivec4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector4) -> ivec4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> ivec4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector4) -> ivec4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> ivec4: ...
    def __imod__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> ivec4: ...

    def __pow__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> ivec4: ...
    def __ipow__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> ivec4: ...

    def __floordiv__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> ivec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.I32Vector4, glm_typing.Number]) -> ivec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> ivec4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector4) -> ivec4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> ivec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector4) -> ivec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: ivec4) -> Tuple[ivec4, ivec4]: ...



class mvec2:
    x: float
    y: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.FAnyVector3, glm_typing.FAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> mvec2: ...
    def __pos__(self) -> mvec2: ...
    def __abs__(self) -> mvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mvec2: ...

    def __add__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> mvec2: ...
    def __iadd__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> mvec2: ...

    def __sub__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> mvec2: ...
    def __isub__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> mvec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> mvec2: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector2) -> mvec2: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> mvec2: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector2) -> mvec2: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> mvec2: ...
    def __imod__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> mvec2: ...

    def __pow__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> mvec2: ...
    def __ipow__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> mvec2: ...

    def __floordiv__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> mvec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> mvec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> mvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector2) -> mvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> mvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector2) -> mvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: mvec2) -> Tuple[mvec2, mvec2]: ...



class mvec3:
    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.FAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> mvec3: ...
    def __pos__(self) -> mvec3: ...
    def __abs__(self) -> mvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mvec3: ...

    def __add__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> mvec3: ...
    def __iadd__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> mvec3: ...

    def __sub__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> mvec3: ...
    def __isub__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> mvec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> mvec3: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector3) -> mvec3: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> mvec3: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector3) -> mvec3: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> mvec3: ...
    def __imod__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> mvec3: ...

    def __pow__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> mvec3: ...
    def __ipow__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> mvec3: ...

    def __floordiv__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> mvec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> mvec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> mvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector3) -> mvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> mvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector3) -> mvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: mvec3) -> Tuple[mvec3, mvec3]: ...



class mvec4:
    x: float
    y: float
    z: float
    w: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> mvec4: ...
    def __pos__(self) -> mvec4: ...
    def __abs__(self) -> mvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mvec4: ...

    def __add__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> mvec4: ...
    def __iadd__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> mvec4: ...

    def __sub__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> mvec4: ...
    def __isub__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> mvec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> mvec4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector4) -> mvec4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> mvec4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector4) -> mvec4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> mvec4: ...
    def __imod__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> mvec4: ...

    def __pow__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> mvec4: ...
    def __ipow__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> mvec4: ...

    def __floordiv__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> mvec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> mvec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> mvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector4) -> mvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> mvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector4) -> mvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: mvec4) -> Tuple[mvec4, mvec4]: ...



class u16vec1:
    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector1, glm_typing.UAnyVector2, glm_typing.UAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u16vec1: ...
    def __pos__(self) -> u16vec1: ...
    def __abs__(self) -> u16vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u16vec1: ...

    def __add__(self, other: Union[glm_typing.U16Vector1, glm_typing.Number]) -> u16vec1: ...
    def __iadd__(self, other: Union[glm_typing.U16Vector1, glm_typing.Number]) -> u16vec1: ...

    def __sub__(self, other: Union[glm_typing.U16Vector1, glm_typing.Number]) -> u16vec1: ...
    def __isub__(self, other: Union[glm_typing.U16Vector1, glm_typing.Number]) -> u16vec1: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> u16vec1: ...
    @overload
    def __mul__(self, other: glm_typing.U16Vector1) -> u16vec1: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> u16vec1: ...
    @overload
    def __imul__(self, other: glm_typing.U16Vector1) -> u16vec1: ...

    def __mod__(self, other: Union[glm_typing.U16Vector1, glm_typing.Number]) -> u16vec1: ...
    def __imod__(self, other: Union[glm_typing.U16Vector1, glm_typing.Number]) -> u16vec1: ...

    def __pow__(self, other: Union[glm_typing.U16Vector1, glm_typing.Number]) -> u16vec1: ...
    def __ipow__(self, other: Union[glm_typing.U16Vector1, glm_typing.Number]) -> u16vec1: ...

    def __floordiv__(self, other: Union[glm_typing.U16Vector1, glm_typing.Number]) -> u16vec1: ...
    def __ifloordiv__(self, other: Union[glm_typing.U16Vector1, glm_typing.Number]) -> u16vec1: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> u16vec1: ...
    @overload
    def __matmul__(self, other: glm_typing.U16Vector1) -> u16vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> u16vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.U16Vector1) -> u16vec1: ...

    def __divmod__(self, other: u16vec1) -> Tuple[u16vec1, u16vec1]: ...



class u16vec2:
    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.UAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u16vec2: ...
    def __pos__(self) -> u16vec2: ...
    def __abs__(self) -> u16vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u16vec2: ...

    def __add__(self, other: Union[glm_typing.U16Vector2, glm_typing.Number]) -> u16vec2: ...
    def __iadd__(self, other: Union[glm_typing.U16Vector2, glm_typing.Number]) -> u16vec2: ...

    def __sub__(self, other: Union[glm_typing.U16Vector2, glm_typing.Number]) -> u16vec2: ...
    def __isub__(self, other: Union[glm_typing.U16Vector2, glm_typing.Number]) -> u16vec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> u16vec2: ...
    @overload
    def __mul__(self, other: glm_typing.U16Vector2) -> u16vec2: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> u16vec2: ...
    @overload
    def __imul__(self, other: glm_typing.U16Vector2) -> u16vec2: ...

    def __mod__(self, other: Union[glm_typing.U16Vector2, glm_typing.Number]) -> u16vec2: ...
    def __imod__(self, other: Union[glm_typing.U16Vector2, glm_typing.Number]) -> u16vec2: ...

    def __pow__(self, other: Union[glm_typing.U16Vector2, glm_typing.Number]) -> u16vec2: ...
    def __ipow__(self, other: Union[glm_typing.U16Vector2, glm_typing.Number]) -> u16vec2: ...

    def __floordiv__(self, other: Union[glm_typing.U16Vector2, glm_typing.Number]) -> u16vec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.U16Vector2, glm_typing.Number]) -> u16vec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> u16vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U16Vector2) -> u16vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> u16vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U16Vector2) -> u16vec2: ...

    def __divmod__(self, other: u16vec2) -> Tuple[u16vec2, u16vec2]: ...



class u16vec3:
    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u16vec3: ...
    def __pos__(self) -> u16vec3: ...
    def __abs__(self) -> u16vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u16vec3: ...

    def __add__(self, other: Union[glm_typing.U16Vector3, glm_typing.Number]) -> u16vec3: ...
    def __iadd__(self, other: Union[glm_typing.U16Vector3, glm_typing.Number]) -> u16vec3: ...

    def __sub__(self, other: Union[glm_typing.U16Vector3, glm_typing.Number]) -> u16vec3: ...
    def __isub__(self, other: Union[glm_typing.U16Vector3, glm_typing.Number]) -> u16vec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> u16vec3: ...
    @overload
    def __mul__(self, other: glm_typing.U16Vector3) -> u16vec3: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> u16vec3: ...
    @overload
    def __imul__(self, other: glm_typing.U16Vector3) -> u16vec3: ...

    def __mod__(self, other: Union[glm_typing.U16Vector3, glm_typing.Number]) -> u16vec3: ...
    def __imod__(self, other: Union[glm_typing.U16Vector3, glm_typing.Number]) -> u16vec3: ...

    def __pow__(self, other: Union[glm_typing.U16Vector3, glm_typing.Number]) -> u16vec3: ...
    def __ipow__(self, other: Union[glm_typing.U16Vector3, glm_typing.Number]) -> u16vec3: ...

    def __floordiv__(self, other: Union[glm_typing.U16Vector3, glm_typing.Number]) -> u16vec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.U16Vector3, glm_typing.Number]) -> u16vec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> u16vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U16Vector3) -> u16vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> u16vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U16Vector3) -> u16vec3: ...

    def __divmod__(self, other: u16vec3) -> Tuple[u16vec3, u16vec3]: ...



class u16vec4:
    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u16vec4: ...
    def __pos__(self) -> u16vec4: ...
    def __abs__(self) -> u16vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u16vec4: ...

    def __add__(self, other: Union[glm_typing.U16Vector4, glm_typing.Number]) -> u16vec4: ...
    def __iadd__(self, other: Union[glm_typing.U16Vector4, glm_typing.Number]) -> u16vec4: ...

    def __sub__(self, other: Union[glm_typing.U16Vector4, glm_typing.Number]) -> u16vec4: ...
    def __isub__(self, other: Union[glm_typing.U16Vector4, glm_typing.Number]) -> u16vec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> u16vec4: ...
    @overload
    def __mul__(self, other: glm_typing.U16Vector4) -> u16vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> u16vec4: ...
    @overload
    def __imul__(self, other: glm_typing.U16Vector4) -> u16vec4: ...

    def __mod__(self, other: Union[glm_typing.U16Vector4, glm_typing.Number]) -> u16vec4: ...
    def __imod__(self, other: Union[glm_typing.U16Vector4, glm_typing.Number]) -> u16vec4: ...

    def __pow__(self, other: Union[glm_typing.U16Vector4, glm_typing.Number]) -> u16vec4: ...
    def __ipow__(self, other: Union[glm_typing.U16Vector4, glm_typing.Number]) -> u16vec4: ...

    def __floordiv__(self, other: Union[glm_typing.U16Vector4, glm_typing.Number]) -> u16vec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.U16Vector4, glm_typing.Number]) -> u16vec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> u16vec4: ...
    @overload
    def __matmul__(self, other: glm_typing.U16Vector4) -> u16vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> u16vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U16Vector4) -> u16vec4: ...

    def __divmod__(self, other: u16vec4) -> Tuple[u16vec4, u16vec4]: ...



class u64vec1:
    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector1, glm_typing.UAnyVector2, glm_typing.UAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u64vec1: ...
    def __pos__(self) -> u64vec1: ...
    def __abs__(self) -> u64vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u64vec1: ...

    def __add__(self, other: Union[glm_typing.U64Vector1, glm_typing.Number]) -> u64vec1: ...
    def __iadd__(self, other: Union[glm_typing.U64Vector1, glm_typing.Number]) -> u64vec1: ...

    def __sub__(self, other: Union[glm_typing.U64Vector1, glm_typing.Number]) -> u64vec1: ...
    def __isub__(self, other: Union[glm_typing.U64Vector1, glm_typing.Number]) -> u64vec1: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> u64vec1: ...
    @overload
    def __mul__(self, other: glm_typing.U64Vector1) -> u64vec1: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> u64vec1: ...
    @overload
    def __imul__(self, other: glm_typing.U64Vector1) -> u64vec1: ...

    def __mod__(self, other: Union[glm_typing.U64Vector1, glm_typing.Number]) -> u64vec1: ...
    def __imod__(self, other: Union[glm_typing.U64Vector1, glm_typing.Number]) -> u64vec1: ...

    def __pow__(self, other: Union[glm_typing.U64Vector1, glm_typing.Number]) -> u64vec1: ...
    def __ipow__(self, other: Union[glm_typing.U64Vector1, glm_typing.Number]) -> u64vec1: ...

    def __floordiv__(self, other: Union[glm_typing.U64Vector1, glm_typing.Number]) -> u64vec1: ...
    def __ifloordiv__(self, other: Union[glm_typing.U64Vector1, glm_typing.Number]) -> u64vec1: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> u64vec1: ...
    @overload
    def __matmul__(self, other: glm_typing.U64Vector1) -> u64vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> u64vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.U64Vector1) -> u64vec1: ...

    def __divmod__(self, other: u64vec1) -> Tuple[u64vec1, u64vec1]: ...



class u64vec2:
    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.UAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u64vec2: ...
    def __pos__(self) -> u64vec2: ...
    def __abs__(self) -> u64vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u64vec2: ...

    def __add__(self, other: Union[glm_typing.U64Vector2, glm_typing.Number]) -> u64vec2: ...
    def __iadd__(self, other: Union[glm_typing.U64Vector2, glm_typing.Number]) -> u64vec2: ...

    def __sub__(self, other: Union[glm_typing.U64Vector2, glm_typing.Number]) -> u64vec2: ...
    def __isub__(self, other: Union[glm_typing.U64Vector2, glm_typing.Number]) -> u64vec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> u64vec2: ...
    @overload
    def __mul__(self, other: glm_typing.U64Vector2) -> u64vec2: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> u64vec2: ...
    @overload
    def __imul__(self, other: glm_typing.U64Vector2) -> u64vec2: ...

    def __mod__(self, other: Union[glm_typing.U64Vector2, glm_typing.Number]) -> u64vec2: ...
    def __imod__(self, other: Union[glm_typing.U64Vector2, glm_typing.Number]) -> u64vec2: ...

    def __pow__(self, other: Union[glm_typing.U64Vector2, glm_typing.Number]) -> u64vec2: ...
    def __ipow__(self, other: Union[glm_typing.U64Vector2, glm_typing.Number]) -> u64vec2: ...

    def __floordiv__(self, other: Union[glm_typing.U64Vector2, glm_typing.Number]) -> u64vec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.U64Vector2, glm_typing.Number]) -> u64vec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> u64vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U64Vector2) -> u64vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> u64vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U64Vector2) -> u64vec2: ...

    def __divmod__(self, other: u64vec2) -> Tuple[u64vec2, u64vec2]: ...



class u64vec3:
    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u64vec3: ...
    def __pos__(self) -> u64vec3: ...
    def __abs__(self) -> u64vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u64vec3: ...

    def __add__(self, other: Union[glm_typing.U64Vector3, glm_typing.Number]) -> u64vec3: ...
    def __iadd__(self, other: Union[glm_typing.U64Vector3, glm_typing.Number]) -> u64vec3: ...

    def __sub__(self, other: Union[glm_typing.U64Vector3, glm_typing.Number]) -> u64vec3: ...
    def __isub__(self, other: Union[glm_typing.U64Vector3, glm_typing.Number]) -> u64vec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> u64vec3: ...
    @overload
    def __mul__(self, other: glm_typing.U64Vector3) -> u64vec3: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> u64vec3: ...
    @overload
    def __imul__(self, other: glm_typing.U64Vector3) -> u64vec3: ...

    def __mod__(self, other: Union[glm_typing.U64Vector3, glm_typing.Number]) -> u64vec3: ...
    def __imod__(self, other: Union[glm_typing.U64Vector3, glm_typing.Number]) -> u64vec3: ...

    def __pow__(self, other: Union[glm_typing.U64Vector3, glm_typing.Number]) -> u64vec3: ...
    def __ipow__(self, other: Union[glm_typing.U64Vector3, glm_typing.Number]) -> u64vec3: ...

    def __floordiv__(self, other: Union[glm_typing.U64Vector3, glm_typing.Number]) -> u64vec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.U64Vector3, glm_typing.Number]) -> u64vec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> u64vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U64Vector3) -> u64vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> u64vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U64Vector3) -> u64vec3: ...

    def __divmod__(self, other: u64vec3) -> Tuple[u64vec3, u64vec3]: ...



class u64vec4:
    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u64vec4: ...
    def __pos__(self) -> u64vec4: ...
    def __abs__(self) -> u64vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u64vec4: ...

    def __add__(self, other: Union[glm_typing.U64Vector4, glm_typing.Number]) -> u64vec4: ...
    def __iadd__(self, other: Union[glm_typing.U64Vector4, glm_typing.Number]) -> u64vec4: ...

    def __sub__(self, other: Union[glm_typing.U64Vector4, glm_typing.Number]) -> u64vec4: ...
    def __isub__(self, other: Union[glm_typing.U64Vector4, glm_typing.Number]) -> u64vec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> u64vec4: ...
    @overload
    def __mul__(self, other: glm_typing.U64Vector4) -> u64vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> u64vec4: ...
    @overload
    def __imul__(self, other: glm_typing.U64Vector4) -> u64vec4: ...

    def __mod__(self, other: Union[glm_typing.U64Vector4, glm_typing.Number]) -> u64vec4: ...
    def __imod__(self, other: Union[glm_typing.U64Vector4, glm_typing.Number]) -> u64vec4: ...

    def __pow__(self, other: Union[glm_typing.U64Vector4, glm_typing.Number]) -> u64vec4: ...
    def __ipow__(self, other: Union[glm_typing.U64Vector4, glm_typing.Number]) -> u64vec4: ...

    def __floordiv__(self, other: Union[glm_typing.U64Vector4, glm_typing.Number]) -> u64vec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.U64Vector4, glm_typing.Number]) -> u64vec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> u64vec4: ...
    @overload
    def __matmul__(self, other: glm_typing.U64Vector4) -> u64vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> u64vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U64Vector4) -> u64vec4: ...

    def __divmod__(self, other: u64vec4) -> Tuple[u64vec4, u64vec4]: ...



class u8vec1:
    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector1, glm_typing.UAnyVector2, glm_typing.UAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u8vec1: ...
    def __pos__(self) -> u8vec1: ...
    def __abs__(self) -> u8vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u8vec1: ...

    def __add__(self, other: Union[glm_typing.U8Vector1, glm_typing.Number]) -> u8vec1: ...
    def __iadd__(self, other: Union[glm_typing.U8Vector1, glm_typing.Number]) -> u8vec1: ...

    def __sub__(self, other: Union[glm_typing.U8Vector1, glm_typing.Number]) -> u8vec1: ...
    def __isub__(self, other: Union[glm_typing.U8Vector1, glm_typing.Number]) -> u8vec1: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> u8vec1: ...
    @overload
    def __mul__(self, other: glm_typing.U8Vector1) -> u8vec1: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> u8vec1: ...
    @overload
    def __imul__(self, other: glm_typing.U8Vector1) -> u8vec1: ...

    def __mod__(self, other: Union[glm_typing.U8Vector1, glm_typing.Number]) -> u8vec1: ...
    def __imod__(self, other: Union[glm_typing.U8Vector1, glm_typing.Number]) -> u8vec1: ...

    def __pow__(self, other: Union[glm_typing.U8Vector1, glm_typing.Number]) -> u8vec1: ...
    def __ipow__(self, other: Union[glm_typing.U8Vector1, glm_typing.Number]) -> u8vec1: ...

    def __floordiv__(self, other: Union[glm_typing.U8Vector1, glm_typing.Number]) -> u8vec1: ...
    def __ifloordiv__(self, other: Union[glm_typing.U8Vector1, glm_typing.Number]) -> u8vec1: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> u8vec1: ...
    @overload
    def __matmul__(self, other: glm_typing.U8Vector1) -> u8vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> u8vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.U8Vector1) -> u8vec1: ...

    def __divmod__(self, other: u8vec1) -> Tuple[u8vec1, u8vec1]: ...



class u8vec2:
    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.UAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u8vec2: ...
    def __pos__(self) -> u8vec2: ...
    def __abs__(self) -> u8vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u8vec2: ...

    def __add__(self, other: Union[glm_typing.U8Vector2, glm_typing.Number]) -> u8vec2: ...
    def __iadd__(self, other: Union[glm_typing.U8Vector2, glm_typing.Number]) -> u8vec2: ...

    def __sub__(self, other: Union[glm_typing.U8Vector2, glm_typing.Number]) -> u8vec2: ...
    def __isub__(self, other: Union[glm_typing.U8Vector2, glm_typing.Number]) -> u8vec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> u8vec2: ...
    @overload
    def __mul__(self, other: glm_typing.U8Vector2) -> u8vec2: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> u8vec2: ...
    @overload
    def __imul__(self, other: glm_typing.U8Vector2) -> u8vec2: ...

    def __mod__(self, other: Union[glm_typing.U8Vector2, glm_typing.Number]) -> u8vec2: ...
    def __imod__(self, other: Union[glm_typing.U8Vector2, glm_typing.Number]) -> u8vec2: ...

    def __pow__(self, other: Union[glm_typing.U8Vector2, glm_typing.Number]) -> u8vec2: ...
    def __ipow__(self, other: Union[glm_typing.U8Vector2, glm_typing.Number]) -> u8vec2: ...

    def __floordiv__(self, other: Union[glm_typing.U8Vector2, glm_typing.Number]) -> u8vec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.U8Vector2, glm_typing.Number]) -> u8vec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> u8vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U8Vector2) -> u8vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> u8vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U8Vector2) -> u8vec2: ...

    def __divmod__(self, other: u8vec2) -> Tuple[u8vec2, u8vec2]: ...



class u8vec3:
    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u8vec3: ...
    def __pos__(self) -> u8vec3: ...
    def __abs__(self) -> u8vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u8vec3: ...

    def __add__(self, other: Union[glm_typing.U8Vector3, glm_typing.Number]) -> u8vec3: ...
    def __iadd__(self, other: Union[glm_typing.U8Vector3, glm_typing.Number]) -> u8vec3: ...

    def __sub__(self, other: Union[glm_typing.U8Vector3, glm_typing.Number]) -> u8vec3: ...
    def __isub__(self, other: Union[glm_typing.U8Vector3, glm_typing.Number]) -> u8vec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> u8vec3: ...
    @overload
    def __mul__(self, other: glm_typing.U8Vector3) -> u8vec3: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> u8vec3: ...
    @overload
    def __imul__(self, other: glm_typing.U8Vector3) -> u8vec3: ...

    def __mod__(self, other: Union[glm_typing.U8Vector3, glm_typing.Number]) -> u8vec3: ...
    def __imod__(self, other: Union[glm_typing.U8Vector3, glm_typing.Number]) -> u8vec3: ...

    def __pow__(self, other: Union[glm_typing.U8Vector3, glm_typing.Number]) -> u8vec3: ...
    def __ipow__(self, other: Union[glm_typing.U8Vector3, glm_typing.Number]) -> u8vec3: ...

    def __floordiv__(self, other: Union[glm_typing.U8Vector3, glm_typing.Number]) -> u8vec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.U8Vector3, glm_typing.Number]) -> u8vec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> u8vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U8Vector3) -> u8vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> u8vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U8Vector3) -> u8vec3: ...

    def __divmod__(self, other: u8vec3) -> Tuple[u8vec3, u8vec3]: ...



class u8vec4:
    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u8vec4: ...
    def __pos__(self) -> u8vec4: ...
    def __abs__(self) -> u8vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u8vec4: ...

    def __add__(self, other: Union[glm_typing.U8Vector4, glm_typing.Number]) -> u8vec4: ...
    def __iadd__(self, other: Union[glm_typing.U8Vector4, glm_typing.Number]) -> u8vec4: ...

    def __sub__(self, other: Union[glm_typing.U8Vector4, glm_typing.Number]) -> u8vec4: ...
    def __isub__(self, other: Union[glm_typing.U8Vector4, glm_typing.Number]) -> u8vec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> u8vec4: ...
    @overload
    def __mul__(self, other: glm_typing.U8Vector4) -> u8vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> u8vec4: ...
    @overload
    def __imul__(self, other: glm_typing.U8Vector4) -> u8vec4: ...

    def __mod__(self, other: Union[glm_typing.U8Vector4, glm_typing.Number]) -> u8vec4: ...
    def __imod__(self, other: Union[glm_typing.U8Vector4, glm_typing.Number]) -> u8vec4: ...

    def __pow__(self, other: Union[glm_typing.U8Vector4, glm_typing.Number]) -> u8vec4: ...
    def __ipow__(self, other: Union[glm_typing.U8Vector4, glm_typing.Number]) -> u8vec4: ...

    def __floordiv__(self, other: Union[glm_typing.U8Vector4, glm_typing.Number]) -> u8vec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.U8Vector4, glm_typing.Number]) -> u8vec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> u8vec4: ...
    @overload
    def __matmul__(self, other: glm_typing.U8Vector4) -> u8vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> u8vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U8Vector4) -> u8vec4: ...

    def __divmod__(self, other: u8vec4) -> Tuple[u8vec4, u8vec4]: ...



class umvec2:
    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.UAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> umvec2: ...
    def __pos__(self) -> umvec2: ...
    def __abs__(self) -> umvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umvec2: ...

    def __add__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> umvec2: ...
    def __iadd__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> umvec2: ...

    def __sub__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> umvec2: ...
    def __isub__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> umvec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> umvec2: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector2) -> umvec2: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> umvec2: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector2) -> umvec2: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> umvec2: ...
    def __imod__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> umvec2: ...

    def __pow__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> umvec2: ...
    def __ipow__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> umvec2: ...

    def __floordiv__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> umvec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> umvec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> umvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector2) -> umvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> umvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector2) -> umvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: umvec2) -> Tuple[umvec2, umvec2]: ...



class umvec3:
    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> umvec3: ...
    def __pos__(self) -> umvec3: ...
    def __abs__(self) -> umvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umvec3: ...

    def __add__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> umvec3: ...
    def __iadd__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> umvec3: ...

    def __sub__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> umvec3: ...
    def __isub__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> umvec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> umvec3: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector3) -> umvec3: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> umvec3: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector3) -> umvec3: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> umvec3: ...
    def __imod__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> umvec3: ...

    def __pow__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> umvec3: ...
    def __ipow__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> umvec3: ...

    def __floordiv__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> umvec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> umvec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> umvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector3) -> umvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> umvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector3) -> umvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: umvec3) -> Tuple[umvec3, umvec3]: ...



class umvec4:
    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> umvec4: ...
    def __pos__(self) -> umvec4: ...
    def __abs__(self) -> umvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umvec4: ...

    def __add__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> umvec4: ...
    def __iadd__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> umvec4: ...

    def __sub__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> umvec4: ...
    def __isub__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> umvec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> umvec4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector4) -> umvec4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> umvec4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector4) -> umvec4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> umvec4: ...
    def __imod__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> umvec4: ...

    def __pow__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> umvec4: ...
    def __ipow__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> umvec4: ...

    def __floordiv__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> umvec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> umvec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> umvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector4) -> umvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> umvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector4) -> umvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: umvec4) -> Tuple[umvec4, umvec4]: ...


u32vec1 = uvec1

class uvec1:
    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector1, glm_typing.UAnyVector2, glm_typing.UAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> uvec1: ...
    def __pos__(self) -> uvec1: ...
    def __abs__(self) -> uvec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> uvec1: ...

    def __add__(self, other: Union[glm_typing.U32Vector1, glm_typing.Number]) -> uvec1: ...
    def __iadd__(self, other: Union[glm_typing.U32Vector1, glm_typing.Number]) -> uvec1: ...

    def __sub__(self, other: Union[glm_typing.U32Vector1, glm_typing.Number]) -> uvec1: ...
    def __isub__(self, other: Union[glm_typing.U32Vector1, glm_typing.Number]) -> uvec1: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> uvec1: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector1) -> uvec1: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> uvec1: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector1) -> uvec1: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.U32Vector1, glm_typing.Number]) -> uvec1: ...
    def __imod__(self, other: Union[glm_typing.U32Vector1, glm_typing.Number]) -> uvec1: ...

    def __pow__(self, other: Union[glm_typing.U32Vector1, glm_typing.Number]) -> uvec1: ...
    def __ipow__(self, other: Union[glm_typing.U32Vector1, glm_typing.Number]) -> uvec1: ...

    def __floordiv__(self, other: Union[glm_typing.U32Vector1, glm_typing.Number]) -> uvec1: ...
    def __ifloordiv__(self, other: Union[glm_typing.U32Vector1, glm_typing.Number]) -> uvec1: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> uvec1: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector1) -> uvec1: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> uvec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector1) -> uvec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: uvec1) -> Tuple[uvec1, uvec1]: ...


u32vec2 = uvec2

class uvec2:
    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.UAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> uvec2: ...
    def __pos__(self) -> uvec2: ...
    def __abs__(self) -> uvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> uvec2: ...

    def __add__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> uvec2: ...
    def __iadd__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> uvec2: ...

    def __sub__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> uvec2: ...
    def __isub__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> uvec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> uvec2: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector2) -> uvec2: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> uvec2: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector2) -> uvec2: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> uvec2: ...
    def __imod__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> uvec2: ...

    def __pow__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> uvec2: ...
    def __ipow__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> uvec2: ...

    def __floordiv__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> uvec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.U32Vector2, glm_typing.Number]) -> uvec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> uvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector2) -> uvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> uvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector2) -> uvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: uvec2) -> Tuple[uvec2, uvec2]: ...


u32vec3 = uvec3

class uvec3:
    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.UAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> uvec3: ...
    def __pos__(self) -> uvec3: ...
    def __abs__(self) -> uvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> uvec3: ...

    def __add__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> uvec3: ...
    def __iadd__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> uvec3: ...

    def __sub__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> uvec3: ...
    def __isub__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> uvec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> uvec3: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector3) -> uvec3: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> uvec3: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector3) -> uvec3: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> uvec3: ...
    def __imod__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> uvec3: ...

    def __pow__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> uvec3: ...
    def __ipow__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> uvec3: ...

    def __floordiv__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> uvec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.U32Vector3, glm_typing.Number]) -> uvec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> uvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector3) -> uvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> uvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector3) -> uvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: uvec3) -> Tuple[uvec3, uvec3]: ...


u32vec4 = uvec4

class uvec4:
    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> uvec4: ...
    def __pos__(self) -> uvec4: ...
    def __abs__(self) -> uvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> uvec4: ...

    def __add__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> uvec4: ...
    def __iadd__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> uvec4: ...

    def __sub__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> uvec4: ...
    def __isub__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> uvec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> uvec4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector4) -> uvec4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> uvec4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector4) -> uvec4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> uvec4: ...
    def __imod__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> uvec4: ...

    def __pow__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> uvec4: ...
    def __ipow__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> uvec4: ...

    def __floordiv__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> uvec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.U32Vector4, glm_typing.Number]) -> uvec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> uvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector4) -> uvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> uvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector4) -> uvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: uvec4) -> Tuple[uvec4, uvec4]: ...


f32vec1 = vec1
fvec1 = vec1

class vec1:
    x: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector1, glm_typing.FAnyVector2, glm_typing.FAnyVector3, glm_typing.FAnyVector4]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> vec1: ...
    def __pos__(self) -> vec1: ...
    def __abs__(self) -> vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> vec1: ...

    def __add__(self, other: Union[glm_typing.F32Vector1, glm_typing.Number]) -> vec1: ...
    def __iadd__(self, other: Union[glm_typing.F32Vector1, glm_typing.Number]) -> vec1: ...

    def __sub__(self, other: Union[glm_typing.F32Vector1, glm_typing.Number]) -> vec1: ...
    def __isub__(self, other: Union[glm_typing.F32Vector1, glm_typing.Number]) -> vec1: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> vec1: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector1) -> vec1: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> vec1: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector1) -> vec1: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.F32Vector1, glm_typing.Number]) -> vec1: ...
    def __imod__(self, other: Union[glm_typing.F32Vector1, glm_typing.Number]) -> vec1: ...

    def __pow__(self, other: Union[glm_typing.F32Vector1, glm_typing.Number]) -> vec1: ...
    def __ipow__(self, other: Union[glm_typing.F32Vector1, glm_typing.Number]) -> vec1: ...

    def __floordiv__(self, other: Union[glm_typing.F32Vector1, glm_typing.Number]) -> vec1: ...
    def __ifloordiv__(self, other: Union[glm_typing.F32Vector1, glm_typing.Number]) -> vec1: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> vec1: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector1) -> vec1: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector1) -> vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: vec1) -> Tuple[vec1, vec1]: ...


f32vec2 = vec2
fvec2 = vec2

class vec2:
    x: float
    y: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector2, glm_typing.FAnyVector3, glm_typing.FAnyVector4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> vec2: ...
    def __pos__(self) -> vec2: ...
    def __abs__(self) -> vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> vec2: ...

    def __add__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> vec2: ...
    def __iadd__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> vec2: ...

    def __sub__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> vec2: ...
    def __isub__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> vec2: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> vec2: ...
    def __imod__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> vec2: ...

    def __pow__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> vec2: ...
    def __ipow__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> vec2: ...

    def __floordiv__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> vec2: ...
    def __ifloordiv__(self, other: Union[glm_typing.F32Vector2, glm_typing.Number]) -> vec2: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: vec2) -> Tuple[vec2, vec2]: ...


f32vec3 = vec3
fvec3 = vec3

class vec3:
    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyVector3, glm_typing.FAnyVector4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> vec3: ...
    def __pos__(self) -> vec3: ...
    def __abs__(self) -> vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> vec3: ...

    def __add__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> vec3: ...
    def __iadd__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> vec3: ...

    def __sub__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> vec3: ...
    def __isub__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> vec3: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> vec3: ...
    def __imod__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> vec3: ...

    def __pow__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> vec3: ...
    def __ipow__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> vec3: ...

    def __floordiv__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> vec3: ...
    def __ifloordiv__(self, other: Union[glm_typing.F32Vector3, glm_typing.Number]) -> vec3: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: vec3) -> Tuple[vec3, vec3]: ...


f32vec4 = vec4
fvec4 = vec4

class vec4:
    x: float
    y: float
    z: float
    w: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number, w: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, x: glm_typing.AnyAnyVector4) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> vec4: ...
    def __pos__(self) -> vec4: ...
    def __abs__(self) -> vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> vec4: ...

    def __add__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> vec4: ...
    def __iadd__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> vec4: ...

    def __sub__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> vec4: ...
    def __isub__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> vec4: ...

    @overload
    def __mul__(self, other: glm_typing.Number) -> vec4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector4) -> vec4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.Number) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector4) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __mod__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> vec4: ...
    def __imod__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> vec4: ...

    def __pow__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> vec4: ...
    def __ipow__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> vec4: ...

    def __floordiv__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> vec4: ...
    def __ifloordiv__(self, other: Union[glm_typing.F32Vector4, glm_typing.Number]) -> vec4: ...

    @overload
    def __matmul__(self, other: glm_typing.Number) -> vec4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector4) -> vec4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.Number) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector4) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix2x2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Matrix4x2) -> vec4: ...

    def __divmod__(self, other: vec4) -> Tuple[vec4, vec4]: ...


dmat2 = dmat2x2
f64mat2 = dmat2x2
f64mat2x2 = dmat2x2

class dmat2x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix2x2, glm_typing.DAnyMatrix2x2, glm_typing.DAnyMatrix2x3, glm_typing.DAnyMatrix2x4, glm_typing.DAnyMatrix3x2, glm_typing.DAnyMatrix3x3, glm_typing.DAnyMatrix3x4, glm_typing.DAnyMatrix4x2, glm_typing.DAnyMatrix4x3, glm_typing.DAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec2, dmvec2]) -> None: ...

    def __neg__(self) -> dmat2x2: ...
    def __pos__(self) -> dmat2x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat2x2: ...

    def __add__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    def __iadd__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...

    def __sub__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    def __isub__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...

    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector2) -> dvec2: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector1) -> dvec1: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector2) -> dvec2: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector1) -> dvec1: ...

    @overload
    def __truediv__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __truediv__(self, other: glm_typing.D64Vector2) -> dvec2: ...
    @overload
    def __itruediv__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __itruediv__(self, other: glm_typing.D64Vector2) -> dvec2: ...

    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector2) -> dvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector1) -> dvec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector2) -> dvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector1) -> dvec1: ...


f64mat2x3 = dmat2x3

class dmat2x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix2x3, glm_typing.DAnyMatrix2x3, glm_typing.DAnyMatrix2x4, glm_typing.DAnyMatrix3x3, glm_typing.DAnyMatrix3x4, glm_typing.DAnyMatrix4x3, glm_typing.DAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec3, dmvec3]) -> None: ...

    def __neg__(self) -> dmat2x3: ...
    def __pos__(self) -> dmat2x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat2x3: ...

    def __add__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    def __iadd__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...

    def __sub__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    def __isub__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...

    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector2) -> dvec3: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector2) -> dvec3: ...

    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector2) -> dvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector2) -> dvec3: ...


f64mat2x4 = dmat2x4

class dmat2x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix2x4, glm_typing.DAnyMatrix2x4, glm_typing.DAnyMatrix3x4, glm_typing.DAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec4, dmvec4]) -> None: ...

    def __neg__(self) -> dmat2x4: ...
    def __pos__(self) -> dmat2x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat2x4: ...

    def __add__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    def __iadd__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...

    def __sub__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    def __isub__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...

    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector2) -> dvec4: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector2) -> dvec4: ...

    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector2) -> dvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix2x2) -> dmat2x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix2x3) -> dmat2x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix2x4) -> dmat2x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector2) -> dvec4: ...


f64mat3x2 = dmat3x2

class dmat3x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix3x2, glm_typing.DAnyMatrix3x2, glm_typing.DAnyMatrix3x3, glm_typing.DAnyMatrix3x4, glm_typing.DAnyMatrix4x2, glm_typing.DAnyMatrix4x3, glm_typing.DAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec2, dmvec2]) -> None: ...

    def __neg__(self) -> dmat3x2: ...
    def __pos__(self) -> dmat3x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat3x2: ...

    def __add__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    def __iadd__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...

    def __sub__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    def __isub__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...

    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector3) -> dvec2: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector3) -> dvec2: ...

    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector3) -> dvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector3) -> dvec2: ...


dmat3 = dmat3x3
f64mat3 = dmat3x3
f64mat3x3 = dmat3x3

class dmat3x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix3x3, glm_typing.DAnyMatrix3x3, glm_typing.DAnyMatrix3x4, glm_typing.DAnyMatrix4x3, glm_typing.DAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec3, dmvec3]) -> None: ...

    def __neg__(self) -> dmat3x3: ...
    def __pos__(self) -> dmat3x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat3x3: ...

    def __add__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    def __iadd__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...

    def __sub__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    def __isub__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...

    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector2) -> dvec2: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector2) -> dvec2: ...

    @overload
    def __truediv__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __truediv__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __itruediv__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __itruediv__(self, other: glm_typing.D64Vector3) -> dvec3: ...

    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector2) -> dvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector2) -> dvec2: ...


f64mat3x4 = dmat3x4

class dmat3x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, _9: glm_typing.Number, _10: glm_typing.Number, _11: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix3x4, glm_typing.DAnyMatrix3x4, glm_typing.DAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec4, dmvec4]) -> None: ...

    def __neg__(self) -> dmat3x4: ...
    def __pos__(self) -> dmat3x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat3x4: ...

    def __add__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    def __iadd__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...

    def __sub__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    def __isub__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...

    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector3) -> dvec4: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector3) -> dvec4: ...

    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector3) -> dvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix3x2) -> dmat3x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix3x3) -> dmat3x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix3x4) -> dmat3x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector3) -> dvec4: ...


f64mat4x2 = dmat4x2

class dmat4x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix4x2, glm_typing.DAnyMatrix4x2, glm_typing.DAnyMatrix4x3, glm_typing.DAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec2, dmvec2]) -> None: ...

    def __neg__(self) -> dmat4x2: ...
    def __pos__(self) -> dmat4x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat4x2: ...

    def __add__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    def __iadd__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...

    def __sub__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    def __isub__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...

    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector4) -> dvec2: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector4) -> dvec2: ...

    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector4) -> dvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector4) -> dvec2: ...


f64mat4x3 = dmat4x3

class dmat4x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, _9: glm_typing.Number, _10: glm_typing.Number, _11: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix4x3, glm_typing.DAnyMatrix4x3, glm_typing.DAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec3, dmvec3]) -> None: ...

    def __neg__(self) -> dmat4x3: ...
    def __pos__(self) -> dmat4x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat4x3: ...

    def __add__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    def __iadd__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...

    def __sub__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    def __isub__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...

    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector4) -> dvec3: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector4) -> dvec3: ...

    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector4) -> dvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector4) -> dvec3: ...


dmat4 = dmat4x4
f64mat4 = dmat4x4
f64mat4x4 = dmat4x4

class dmat4x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, _9: glm_typing.Number, _10: glm_typing.Number, _11: glm_typing.Number, _12: glm_typing.Number, _13: glm_typing.Number, _14: glm_typing.Number, _15: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix4x4, glm_typing.DAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec4, dmvec4]) -> None: ...

    def __neg__(self) -> dmat4x4: ...
    def __pos__(self) -> dmat4x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat4x4: ...

    def __add__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    def __iadd__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...

    def __sub__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    def __isub__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...

    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    @overload
    def __mul__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector4) -> dvec4: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    @overload
    def __imul__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector4) -> dvec4: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector3) -> dvec3: ...

    @overload
    def __truediv__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __truediv__(self, other: glm_typing.D64Vector4) -> dvec4: ...
    @overload
    def __itruediv__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __itruediv__(self, other: glm_typing.D64Vector4) -> dvec4: ...

    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    @overload
    def __matmul__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector4) -> dvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix4x2) -> dmat4x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix4x3) -> dmat4x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.DAnyMatrix4x4) -> dmat4x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector4) -> dvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector3) -> dvec3: ...


i32mat2 = imat2x2
i32mat2x2 = imat2x2
imat2 = imat2x2

class imat2x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix2x2, glm_typing.IAnyMatrix2x2, glm_typing.IAnyMatrix2x3, glm_typing.IAnyMatrix2x4, glm_typing.IAnyMatrix3x2, glm_typing.IAnyMatrix3x3, glm_typing.IAnyMatrix3x4, glm_typing.IAnyMatrix4x2, glm_typing.IAnyMatrix4x3, glm_typing.IAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec2, imvec2]) -> None: ...

    def __neg__(self) -> imat2x2: ...
    def __pos__(self) -> imat2x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat2x2: ...

    def __add__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    def __iadd__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...

    def __sub__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    def __isub__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...

    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector2) -> ivec2: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector1) -> ivec1: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector2) -> ivec2: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector1) -> ivec1: ...

    @overload
    def __truediv__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __truediv__(self, other: glm_typing.I32Vector2) -> ivec2: ...
    @overload
    def __itruediv__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __itruediv__(self, other: glm_typing.I32Vector2) -> ivec2: ...

    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector2) -> ivec2: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector1) -> ivec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector2) -> ivec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector1) -> ivec1: ...


i32mat2x3 = imat2x3

class imat2x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix2x3, glm_typing.IAnyMatrix2x3, glm_typing.IAnyMatrix2x4, glm_typing.IAnyMatrix3x3, glm_typing.IAnyMatrix3x4, glm_typing.IAnyMatrix4x3, glm_typing.IAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec3, imvec3]) -> None: ...

    def __neg__(self) -> imat2x3: ...
    def __pos__(self) -> imat2x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat2x3: ...

    def __add__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    def __iadd__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...

    def __sub__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    def __isub__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...

    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector2) -> ivec3: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector2) -> ivec3: ...

    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector2) -> ivec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector2) -> ivec3: ...


i32mat2x4 = imat2x4

class imat2x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix2x4, glm_typing.IAnyMatrix2x4, glm_typing.IAnyMatrix3x4, glm_typing.IAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec4, imvec4]) -> None: ...

    def __neg__(self) -> imat2x4: ...
    def __pos__(self) -> imat2x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat2x4: ...

    def __add__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    def __iadd__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...

    def __sub__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    def __isub__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...

    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector2) -> ivec4: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector2) -> ivec4: ...

    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector2) -> ivec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix2x2) -> imat2x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix2x3) -> imat2x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix2x4) -> imat2x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector2) -> ivec4: ...


i32mat3x2 = imat3x2

class imat3x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix3x2, glm_typing.IAnyMatrix3x2, glm_typing.IAnyMatrix3x3, glm_typing.IAnyMatrix3x4, glm_typing.IAnyMatrix4x2, glm_typing.IAnyMatrix4x3, glm_typing.IAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec2, imvec2]) -> None: ...

    def __neg__(self) -> imat3x2: ...
    def __pos__(self) -> imat3x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat3x2: ...

    def __add__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    def __iadd__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...

    def __sub__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    def __isub__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...

    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector3) -> ivec2: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector3) -> ivec2: ...

    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector3) -> ivec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector3) -> ivec2: ...


i32mat3 = imat3x3
i32mat3x3 = imat3x3
imat3 = imat3x3

class imat3x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix3x3, glm_typing.IAnyMatrix3x3, glm_typing.IAnyMatrix3x4, glm_typing.IAnyMatrix4x3, glm_typing.IAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec3, imvec3]) -> None: ...

    def __neg__(self) -> imat3x3: ...
    def __pos__(self) -> imat3x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat3x3: ...

    def __add__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    def __iadd__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...

    def __sub__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    def __isub__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...

    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector3) -> ivec3: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector2) -> ivec2: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector3) -> ivec3: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector2) -> ivec2: ...

    @overload
    def __truediv__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __truediv__(self, other: glm_typing.I32Vector3) -> ivec3: ...
    @overload
    def __itruediv__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __itruediv__(self, other: glm_typing.I32Vector3) -> ivec3: ...

    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector3) -> ivec3: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector2) -> ivec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector3) -> ivec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector2) -> ivec2: ...


i32mat3x4 = imat3x4

class imat3x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, _9: glm_typing.Number, _10: glm_typing.Number, _11: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix3x4, glm_typing.IAnyMatrix3x4, glm_typing.IAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec4, imvec4]) -> None: ...

    def __neg__(self) -> imat3x4: ...
    def __pos__(self) -> imat3x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat3x4: ...

    def __add__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    def __iadd__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...

    def __sub__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    def __isub__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...

    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector3) -> ivec4: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector3) -> ivec4: ...

    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector3) -> ivec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix3x2) -> imat3x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix3x3) -> imat3x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix3x4) -> imat3x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector3) -> ivec4: ...


i32mat4x2 = imat4x2

class imat4x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix4x2, glm_typing.IAnyMatrix4x2, glm_typing.IAnyMatrix4x3, glm_typing.IAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec2, imvec2]) -> None: ...

    def __neg__(self) -> imat4x2: ...
    def __pos__(self) -> imat4x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat4x2: ...

    def __add__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    def __iadd__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...

    def __sub__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    def __isub__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...

    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector4) -> ivec2: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector4) -> ivec2: ...

    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector4) -> ivec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector4) -> ivec2: ...


i32mat4x3 = imat4x3

class imat4x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, _9: glm_typing.Number, _10: glm_typing.Number, _11: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix4x3, glm_typing.IAnyMatrix4x3, glm_typing.IAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec3, imvec3]) -> None: ...

    def __neg__(self) -> imat4x3: ...
    def __pos__(self) -> imat4x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat4x3: ...

    def __add__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    def __iadd__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...

    def __sub__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    def __isub__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...

    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector4) -> ivec3: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector4) -> ivec3: ...

    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector4) -> ivec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector4) -> ivec3: ...


i32mat4 = imat4x4
i32mat4x4 = imat4x4
imat4 = imat4x4

class imat4x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, _9: glm_typing.Number, _10: glm_typing.Number, _11: glm_typing.Number, _12: glm_typing.Number, _13: glm_typing.Number, _14: glm_typing.Number, _15: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix4x4, glm_typing.IAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec4, imvec4]) -> None: ...

    def __neg__(self) -> imat4x4: ...
    def __pos__(self) -> imat4x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat4x4: ...

    def __add__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    def __iadd__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...

    def __sub__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    def __isub__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...

    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    @overload
    def __mul__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector4) -> ivec4: ...
    @overload
    def __mul__(self, other: glm_typing.I32Vector3) -> ivec3: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    @overload
    def __imul__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector4) -> ivec4: ...
    @overload
    def __imul__(self, other: glm_typing.I32Vector3) -> ivec3: ...

    @overload
    def __truediv__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __truediv__(self, other: glm_typing.I32Vector4) -> ivec4: ...
    @overload
    def __itruediv__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __itruediv__(self, other: glm_typing.I32Vector4) -> ivec4: ...

    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    @overload
    def __matmul__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector4) -> ivec4: ...
    @overload
    def __matmul__(self, other: glm_typing.I32Vector3) -> ivec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix4x2) -> imat4x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix4x3) -> imat4x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.IAnyMatrix4x4) -> imat4x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector4) -> ivec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.I32Vector3) -> ivec3: ...


f32mat2 = mat2x2
f32mat2x2 = mat2x2
fmat2 = mat2x2
fmat2x2 = mat2x2
mat2 = mat2x2

class mat2x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix2x2, glm_typing.FAnyMatrix2x2, glm_typing.FAnyMatrix2x3, glm_typing.FAnyMatrix2x4, glm_typing.FAnyMatrix3x2, glm_typing.FAnyMatrix3x3, glm_typing.FAnyMatrix3x4, glm_typing.FAnyMatrix4x2, glm_typing.FAnyMatrix4x3, glm_typing.FAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec2, mvec2]) -> None: ...

    def __neg__(self) -> mat2x2: ...
    def __pos__(self) -> mat2x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat2x2: ...

    def __add__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    def __iadd__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...

    def __sub__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    def __isub__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...

    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector2) -> vec2: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector1) -> vec1: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector1) -> vec1: ...

    @overload
    def __truediv__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __truediv__(self, other: glm_typing.F32Vector2) -> vec2: ...
    @overload
    def __itruediv__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __itruediv__(self, other: glm_typing.F32Vector2) -> vec2: ...

    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector2) -> vec2: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector1) -> vec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector1) -> vec1: ...


f32mat2x3 = mat2x3
fmat2x3 = mat2x3

class mat2x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix2x3, glm_typing.FAnyMatrix2x3, glm_typing.FAnyMatrix2x4, glm_typing.FAnyMatrix3x3, glm_typing.FAnyMatrix3x4, glm_typing.FAnyMatrix4x3, glm_typing.FAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec3, mvec3]) -> None: ...

    def __neg__(self) -> mat2x3: ...
    def __pos__(self) -> mat2x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat2x3: ...

    def __add__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    def __iadd__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...

    def __sub__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    def __isub__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...

    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector2) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector2) -> vec3: ...

    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector2) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector2) -> vec3: ...


f32mat2x4 = mat2x4
fmat2x4 = mat2x4

class mat2x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix2x4, glm_typing.FAnyMatrix2x4, glm_typing.FAnyMatrix3x4, glm_typing.FAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec4, mvec4]) -> None: ...

    def __neg__(self) -> mat2x4: ...
    def __pos__(self) -> mat2x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat2x4: ...

    def __add__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    def __iadd__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...

    def __sub__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    def __isub__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...

    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector2) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector2) -> vec4: ...

    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector2) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix2x2) -> mat2x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix2x3) -> mat2x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix2x4) -> mat2x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector2) -> vec4: ...


f32mat3x2 = mat3x2
fmat3x2 = mat3x2

class mat3x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix3x2, glm_typing.FAnyMatrix3x2, glm_typing.FAnyMatrix3x3, glm_typing.FAnyMatrix3x4, glm_typing.FAnyMatrix4x2, glm_typing.FAnyMatrix4x3, glm_typing.FAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec2, mvec2]) -> None: ...

    def __neg__(self) -> mat3x2: ...
    def __pos__(self) -> mat3x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat3x2: ...

    def __add__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    def __iadd__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...

    def __sub__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    def __isub__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...

    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector3) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector3) -> vec2: ...

    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector3) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector3) -> vec2: ...


f32mat3 = mat3x3
f32mat3x3 = mat3x3
fmat3 = mat3x3
fmat3x3 = mat3x3
mat3 = mat3x3

class mat3x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix3x3, glm_typing.FAnyMatrix3x3, glm_typing.FAnyMatrix3x4, glm_typing.FAnyMatrix4x3, glm_typing.FAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec3, mvec3]) -> None: ...

    def __neg__(self) -> mat3x3: ...
    def __pos__(self) -> mat3x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat3x3: ...

    def __add__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    def __iadd__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...

    def __sub__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    def __isub__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...

    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector2) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector2) -> vec2: ...

    @overload
    def __truediv__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __truediv__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __itruediv__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __itruediv__(self, other: glm_typing.F32Vector3) -> vec3: ...

    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector2) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector2) -> vec2: ...


f32mat3x4 = mat3x4
fmat3x4 = mat3x4

class mat3x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, _9: glm_typing.Number, _10: glm_typing.Number, _11: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix3x4, glm_typing.FAnyMatrix3x4, glm_typing.FAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec4, mvec4]) -> None: ...

    def __neg__(self) -> mat3x4: ...
    def __pos__(self) -> mat3x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat3x4: ...

    def __add__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    def __iadd__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...

    def __sub__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    def __isub__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...

    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector3) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector3) -> vec4: ...

    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector3) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix3x2) -> mat3x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix3x3) -> mat3x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix3x4) -> mat3x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector3) -> vec4: ...


f32mat4x2 = mat4x2
fmat4x2 = mat4x2

class mat4x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix4x2, glm_typing.FAnyMatrix4x2, glm_typing.FAnyMatrix4x3, glm_typing.FAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec2, mvec2]) -> None: ...

    def __neg__(self) -> mat4x2: ...
    def __pos__(self) -> mat4x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat4x2: ...

    def __add__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    def __iadd__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...

    def __sub__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    def __isub__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...

    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector4) -> vec2: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector4) -> vec2: ...

    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector4) -> vec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector4) -> vec2: ...


f32mat4x3 = mat4x3
fmat4x3 = mat4x3

class mat4x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, _9: glm_typing.Number, _10: glm_typing.Number, _11: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix4x3, glm_typing.FAnyMatrix4x3, glm_typing.FAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec3, mvec3]) -> None: ...

    def __neg__(self) -> mat4x3: ...
    def __pos__(self) -> mat4x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat4x3: ...

    def __add__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    def __iadd__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...

    def __sub__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    def __isub__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...

    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector4) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector4) -> vec3: ...

    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector4) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector4) -> vec3: ...


f32mat4 = mat4x4
f32mat4x4 = mat4x4
fmat4 = mat4x4
fmat4x4 = mat4x4
mat4 = mat4x4

class mat4x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, _9: glm_typing.Number, _10: glm_typing.Number, _11: glm_typing.Number, _12: glm_typing.Number, _13: glm_typing.Number, _14: glm_typing.Number, _15: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix4x4, glm_typing.FAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec4, mvec4]) -> None: ...

    def __neg__(self) -> mat4x4: ...
    def __pos__(self) -> mat4x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat4x4: ...

    def __add__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    def __iadd__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...

    def __sub__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    def __isub__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...

    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    @overload
    def __mul__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector4) -> vec4: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    @overload
    def __imul__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector4) -> vec4: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector3) -> vec3: ...

    @overload
    def __truediv__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __truediv__(self, other: glm_typing.F32Vector4) -> vec4: ...
    @overload
    def __itruediv__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __itruediv__(self, other: glm_typing.F32Vector4) -> vec4: ...

    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    @overload
    def __matmul__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector4) -> vec4: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix4x2) -> mat4x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix4x3) -> mat4x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.FAnyMatrix4x4) -> mat4x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector4) -> vec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector3) -> vec3: ...


u32mat2 = umat2x2
u32mat2x2 = umat2x2
umat2 = umat2x2

class umat2x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix2x2, glm_typing.UAnyMatrix2x2, glm_typing.UAnyMatrix2x3, glm_typing.UAnyMatrix2x4, glm_typing.UAnyMatrix3x2, glm_typing.UAnyMatrix3x3, glm_typing.UAnyMatrix3x4, glm_typing.UAnyMatrix4x2, glm_typing.UAnyMatrix4x3, glm_typing.UAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec2, umvec2]) -> None: ...

    def __neg__(self) -> umat2x2: ...
    def __pos__(self) -> umat2x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat2x2: ...

    def __add__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    def __iadd__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...

    def __sub__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    def __isub__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...

    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector2) -> uvec2: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector1) -> uvec1: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector2) -> uvec2: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector1) -> uvec1: ...

    @overload
    def __truediv__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __truediv__(self, other: glm_typing.U32Vector2) -> uvec2: ...
    @overload
    def __itruediv__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __itruediv__(self, other: glm_typing.U32Vector2) -> uvec2: ...

    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector2) -> uvec2: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector1) -> uvec1: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector2) -> uvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector1) -> uvec1: ...


u32mat2x3 = umat2x3

class umat2x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix2x3, glm_typing.UAnyMatrix2x3, glm_typing.UAnyMatrix2x4, glm_typing.UAnyMatrix3x3, glm_typing.UAnyMatrix3x4, glm_typing.UAnyMatrix4x3, glm_typing.UAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec3, umvec3]) -> None: ...

    def __neg__(self) -> umat2x3: ...
    def __pos__(self) -> umat2x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat2x3: ...

    def __add__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    def __iadd__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...

    def __sub__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    def __isub__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...

    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector2) -> uvec3: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector2) -> uvec3: ...

    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector2) -> uvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector2) -> uvec3: ...


u32mat2x4 = umat2x4

class umat2x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix2x4, glm_typing.UAnyMatrix2x4, glm_typing.UAnyMatrix3x4, glm_typing.UAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec4, umvec4]) -> None: ...

    def __neg__(self) -> umat2x4: ...
    def __pos__(self) -> umat2x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat2x4: ...

    def __add__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    def __iadd__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...

    def __sub__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    def __isub__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...

    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector2) -> uvec4: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector2) -> uvec4: ...

    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector2) -> uvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix2x2) -> umat2x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix2x3) -> umat2x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix2x4) -> umat2x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector2) -> uvec4: ...


u32mat3x2 = umat3x2

class umat3x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix3x2, glm_typing.UAnyMatrix3x2, glm_typing.UAnyMatrix3x3, glm_typing.UAnyMatrix3x4, glm_typing.UAnyMatrix4x2, glm_typing.UAnyMatrix4x3, glm_typing.UAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec2, umvec2]) -> None: ...

    def __neg__(self) -> umat3x2: ...
    def __pos__(self) -> umat3x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat3x2: ...

    def __add__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    def __iadd__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...

    def __sub__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    def __isub__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...

    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector3) -> uvec2: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector3) -> uvec2: ...

    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector3) -> uvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector3) -> uvec2: ...


u32mat3 = umat3x3
u32mat3x3 = umat3x3
umat3 = umat3x3

class umat3x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix3x3, glm_typing.UAnyMatrix3x3, glm_typing.UAnyMatrix3x4, glm_typing.UAnyMatrix4x3, glm_typing.UAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec3, umvec3]) -> None: ...

    def __neg__(self) -> umat3x3: ...
    def __pos__(self) -> umat3x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat3x3: ...

    def __add__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    def __iadd__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...

    def __sub__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    def __isub__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...

    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector3) -> uvec3: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector2) -> uvec2: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector3) -> uvec3: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector2) -> uvec2: ...

    @overload
    def __truediv__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __truediv__(self, other: glm_typing.U32Vector3) -> uvec3: ...
    @overload
    def __itruediv__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __itruediv__(self, other: glm_typing.U32Vector3) -> uvec3: ...

    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector3) -> uvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector2) -> uvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector3) -> uvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector2) -> uvec2: ...


u32mat3x4 = umat3x4

class umat3x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, _9: glm_typing.Number, _10: glm_typing.Number, _11: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix3x4, glm_typing.UAnyMatrix3x4, glm_typing.UAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec4, umvec4]) -> None: ...

    def __neg__(self) -> umat3x4: ...
    def __pos__(self) -> umat3x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat3x4: ...

    def __add__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    def __iadd__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...

    def __sub__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    def __isub__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...

    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector3) -> uvec4: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector3) -> uvec4: ...

    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector3) -> uvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix3x2) -> umat3x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix3x3) -> umat3x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix3x4) -> umat3x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector3) -> uvec4: ...


u32mat4x2 = umat4x2

class umat4x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix4x2, glm_typing.UAnyMatrix4x2, glm_typing.UAnyMatrix4x3, glm_typing.UAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec2, umvec2]) -> None: ...

    def __neg__(self) -> umat4x2: ...
    def __pos__(self) -> umat4x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat4x2: ...

    def __add__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    def __iadd__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...

    def __sub__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    def __isub__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...

    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector4) -> uvec2: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector4) -> uvec2: ...

    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector4) -> uvec2: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector4) -> uvec2: ...


u32mat4x3 = umat4x3

class umat4x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, _9: glm_typing.Number, _10: glm_typing.Number, _11: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix4x3, glm_typing.UAnyMatrix4x3, glm_typing.UAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec3, umvec3]) -> None: ...

    def __neg__(self) -> umat4x3: ...
    def __pos__(self) -> umat4x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat4x3: ...

    def __add__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    def __iadd__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...

    def __sub__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    def __isub__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...

    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector4) -> uvec3: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector4) -> uvec3: ...

    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector4) -> uvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector4) -> uvec3: ...


u32mat4 = umat4x4
u32mat4x4 = umat4x4
umat4 = umat4x4

class umat4x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, _0: glm_typing.Number, _1: glm_typing.Number, _2: glm_typing.Number, _3: glm_typing.Number, _4: glm_typing.Number, _5: glm_typing.Number, _6: glm_typing.Number, _7: glm_typing.Number, _8: glm_typing.Number, _9: glm_typing.Number, _10: glm_typing.Number, _11: glm_typing.Number, _12: glm_typing.Number, _13: glm_typing.Number, _14: glm_typing.Number, _15: glm_typing.Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[glm_typing.AnyAnyMatrix4x4, glm_typing.UAnyMatrix4x4], /) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: glm_typing.Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec4, umvec4]) -> None: ...

    def __neg__(self) -> umat4x4: ...
    def __pos__(self) -> umat4x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat4x4: ...

    def __add__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    def __iadd__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...

    def __sub__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    def __isub__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...

    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    @overload
    def __mul__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector4) -> uvec4: ...
    @overload
    def __mul__(self, other: glm_typing.U32Vector3) -> uvec3: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    @overload
    def __imul__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector4) -> uvec4: ...
    @overload
    def __imul__(self, other: glm_typing.U32Vector3) -> uvec3: ...

    @overload
    def __truediv__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __truediv__(self, other: glm_typing.U32Vector4) -> uvec4: ...
    @overload
    def __itruediv__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __itruediv__(self, other: glm_typing.U32Vector4) -> uvec4: ...

    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    @overload
    def __matmul__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector4) -> uvec4: ...
    @overload
    def __matmul__(self, other: glm_typing.U32Vector3) -> uvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix4x2) -> umat4x2: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix4x3) -> umat4x3: ...
    @overload
    def __imatmul__(self, other: glm_typing.UAnyMatrix4x4) -> umat4x4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector4) -> uvec4: ...
    @overload
    def __imatmul__(self, other: glm_typing.U32Vector3) -> uvec3: ...


f64quat = dquat

class dquat:
    w: float
    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, w: glm_typing.Number, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, w: Union[glm_typing.AnyAnyQuaternion, glm_typing.D64Matrix3x3, glm_typing.D64Matrix4x4, glm_typing.D64Vector3]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dquat: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    @overload
    def __mul__(self, other: Union[dquat, glm_typing.Number]) -> dquat: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __mul__(self, other: glm_typing.D64Vector4) -> dvec4: ...
    @overload
    def __imul__(self, other: Union[dquat, glm_typing.Number]) -> dquat: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __imul__(self, other: glm_typing.D64Vector4) -> dvec4: ...

    @overload
    def __matmul__(self, other: Union[dquat, glm_typing.Number]) -> dquat: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __matmul__(self, other: glm_typing.D64Vector4) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Union[dquat, glm_typing.Number]) -> dquat: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector3) -> dvec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.D64Vector4) -> dvec4: ...


f32quat = quat
fquat = quat

class quat:
    w: float
    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, w: glm_typing.Number, x: glm_typing.Number, y: glm_typing.Number, z: glm_typing.Number) -> None: ...
    @overload
    def __init__(self, w: Union[glm_typing.AnyAnyQuaternion, glm_typing.F32Matrix3x3, glm_typing.F32Matrix4x4, glm_typing.F32Vector3]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: glm_typing.Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> quat: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    @overload
    def __mul__(self, other: Union[quat, glm_typing.Number]) -> quat: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __mul__(self, other: glm_typing.F32Vector4) -> vec4: ...
    @overload
    def __imul__(self, other: Union[quat, glm_typing.Number]) -> quat: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __imul__(self, other: glm_typing.F32Vector4) -> vec4: ...

    @overload
    def __matmul__(self, other: Union[quat, glm_typing.Number]) -> quat: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __matmul__(self, other: glm_typing.F32Vector4) -> vec4: ...
    @overload
    def __imatmul__(self, other: Union[quat, glm_typing.Number]) -> quat: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector3) -> vec3: ...
    @overload
    def __imatmul__(self, other: glm_typing.F32Vector4) -> vec4: ...



_AT = TypeVar('_AT', ctypes.c_bool, ctypes.c_byte, ctypes.c_int8, ctypes.c_ubyte, ctypes.c_uint8, ctypes.c_short, ctypes.c_int16, ctypes.c_ushort, ctypes.c_uint16, ctypes.c_int, ctypes.c_int32, ctypes.c_uint, ctypes.c_uint32, ctypes.c_long, ctypes.c_int64, ctypes.c_ulong, ctypes.c_uint64, ctypes.c_longlong, ctypes.c_ulonglong, ctypes.c_size_t, ctypes.c_ssize_t, ctypes.c_float, ctypes.c_double, ctypes.c_longdouble, dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4, dquat, quat, bvec1, bvec2, bvec3, bvec4, dmvec2, dmvec3, dmvec4, dvec1, dvec2, dvec3, dvec4, i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, i8vec2, i8vec3, i8vec4, imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4, mvec2, mvec3, mvec4, u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, u8vec2, u8vec3, u8vec4, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4, vec1, vec2, vec3, vec4)
_AT2 = TypeVar('_AT2', ctypes.c_bool, ctypes.c_byte, ctypes.c_int8, ctypes.c_ubyte, ctypes.c_uint8, ctypes.c_short, ctypes.c_int16, ctypes.c_ushort, ctypes.c_uint16, ctypes.c_int, ctypes.c_int32, ctypes.c_uint, ctypes.c_uint32, ctypes.c_long, ctypes.c_int64, ctypes.c_ulong, ctypes.c_uint64, ctypes.c_longlong, ctypes.c_ulonglong, ctypes.c_size_t, ctypes.c_ssize_t, ctypes.c_float, ctypes.c_double, ctypes.c_longdouble, dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4, dquat, quat, bvec1, bvec2, bvec3, bvec4, dmvec2, dmvec3, dmvec4, dvec1, dvec2, dvec3, dvec4, i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, i8vec2, i8vec3, i8vec4, imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4, mvec2, mvec3, mvec4, u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, u8vec2, u8vec3, u8vec4, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4, vec1, vec2, vec3, vec4)
_GLMT = TypeVar('_GLMT', dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4, dquat, quat, bvec1, bvec2, bvec3, bvec4, dmvec2, dmvec3, dmvec4, dvec1, dvec2, dvec3, dvec4, i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, i8vec2, i8vec3, i8vec4, imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4, mvec2, mvec3, mvec4, u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, u8vec2, u8vec3, u8vec4, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4, vec1, vec2, vec3, vec4)
_CT = TypeVar('_CT', ctypes.c_bool, ctypes.c_byte, ctypes.c_int8, ctypes.c_ubyte, ctypes.c_uint8, ctypes.c_short, ctypes.c_int16, ctypes.c_ushort, ctypes.c_uint16, ctypes.c_int, ctypes.c_int32, ctypes.c_uint, ctypes.c_uint32, ctypes.c_long, ctypes.c_int64, ctypes.c_ulong, ctypes.c_uint64, ctypes.c_longlong, ctypes.c_ulonglong, ctypes.c_size_t, ctypes.c_ssize_t, ctypes.c_float, ctypes.c_double, ctypes.c_longdouble)
_ICT = TypeVar('_ICT', ctypes.c_bool, ctypes.c_byte, ctypes.c_int8, ctypes.c_ubyte, ctypes.c_uint8, ctypes.c_short, ctypes.c_int16, ctypes.c_ushort, ctypes.c_uint16, ctypes.c_int, ctypes.c_int32, ctypes.c_uint, ctypes.c_uint32, ctypes.c_long, ctypes.c_int64, ctypes.c_ulong, ctypes.c_uint64, ctypes.c_longlong, ctypes.c_ulonglong, ctypes.c_size_t, ctypes.c_ssize_t)
_FCT = TypeVar('_FCT', ctypes.c_bool, ctypes.c_byte, ctypes.c_int8, ctypes.c_ubyte, ctypes.c_uint8, ctypes.c_short, ctypes.c_int16, ctypes.c_ushort, ctypes.c_uint16, ctypes.c_int, ctypes.c_int32, ctypes.c_uint, ctypes.c_uint32, ctypes.c_long, ctypes.c_int64, ctypes.c_ulong, ctypes.c_uint64, ctypes.c_longlong, ctypes.c_ulonglong, ctypes.c_size_t, ctypes.c_ssize_t)

class array(Generic[_AT]):

    nbytes: int
    typecode: str
    element_type: Type[_AT]
    itemsize: int
    dt_size: int
    address: int
    length: int
    readonly: bool
    reference: Any

    @property
    def ptr(self) -> ctypes.c_void_p: ...

    @property
    def dtype(self) -> str: ...

    @property
    def ctype(self) -> Type[Union[ctypes.c_bool, ctypes.c_byte, ctypes.c_int8, ctypes.c_ubyte, ctypes.c_uint8, ctypes.c_short, ctypes.c_int16, ctypes.c_ushort, ctypes.c_uint16, ctypes.c_int, ctypes.c_int32, ctypes.c_uint, ctypes.c_uint32, ctypes.c_long, ctypes.c_int64, ctypes.c_ulong, ctypes.c_uint64, ctypes.c_longlong, ctypes.c_ulonglong, ctypes.c_size_t, ctypes.c_ssize_t, ctypes.c_float, ctypes.c_double, ctypes.c_longdouble]]: ...

    @overload
    def __init__(self, _1: _AT, /, *_: _AT) -> None: ...
    @overload
    def __init__(self, _: array[_AT], /) -> None: ...
    @overload
    def __init__(self, _: Iterable[_AT], /) -> None: ...

    def __len__(self) -> int: ...
    def __contains__(self, value: Any) -> bool: ...

    @overload
    def __iter__(self: array[_GLMT]) -> Generator[_GLMT, None, None]: ...
    @overload
    def __iter__(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]]) -> Generator[int, None, None]: ...
    @overload
    def __iter__(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]]) -> Generator[float, None, None]: ...

    @overload
    def __getitem__(self: array[_GLMT], index: int) -> _GLMT: ...
    @overload
    def __getitem__(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]], index: int) -> int: ...
    @overload
    def __getitem__(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]], index: int) -> float: ...
    @overload
    def __getitem__(self, index: slice) -> array[_AT]: ...

    @overload
    def __setitem__(self: array[_GLMT], index: int, value: _GLMT) -> None: ...
    @overload
    def __setitem__(self: array[_ICT], index: int, value: _ICT) -> None: ...
    @overload
    def __setitem__(self: array[_FCT], index: int, value: _FCT) -> None: ...
    @overload
    def __setitem__(self, index: slice, value: array[_AT]) -> None: ...

    @staticmethod
    def from_bytes(bytes: bytes, type: Type[_AT], /) -> array[_AT]: ...

    @staticmethod
    def from_numbers(type: Type[_CT], /, *numbers: glm_typing.Number) -> array[_CT]: ...

    @staticmethod
    def zeros(type: Type[_AT], length: int, /) -> array[_AT]: ...

    @overload
    def to_list(self: array[_GLMT]) -> List[_GLMT]: ...
    @overload
    def to_list(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]]) -> List[int]: ...
    @overload
    def to_list(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]]) -> List[float]: ...

    @overload
    def to_tuple(self: array[_GLMT]) -> Tuple[_GLMT, ...]: ...
    @overload
    def to_tuple(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]]) -> Tuple[int, ...]: ...
    @overload
    def to_tuple(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]]) -> Tuple[float, ...]: ...

    @overload
    def split_components(self: array[bvec1]) -> Tuple[array[ctypes.c_bool]]: ...
    @overload
    def split_components(self: array[bvec2]) -> Tuple[array[ctypes.c_bool], array[ctypes.c_bool]]: ...
    @overload
    def split_components(self: array[bvec3]) -> Tuple[array[ctypes.c_bool], array[ctypes.c_bool], array[ctypes.c_bool]]: ...
    @overload
    def split_components(self: array[bvec4]) -> Tuple[array[ctypes.c_bool], array[ctypes.c_bool], array[ctypes.c_bool], array[ctypes.c_bool]]: ...
    @overload
    def split_components(self: array[dmvec2]) -> Tuple[array[ctypes.c_double], array[ctypes.c_double]]: ...
    @overload
    def split_components(self: array[dmvec3]) -> Tuple[array[ctypes.c_double], array[ctypes.c_double], array[ctypes.c_double]]: ...
    @overload
    def split_components(self: array[dmvec4]) -> Tuple[array[ctypes.c_double], array[ctypes.c_double], array[ctypes.c_double], array[ctypes.c_double]]: ...
    @overload
    def split_components(self: array[dvec1]) -> Tuple[array[ctypes.c_double]]: ...
    @overload
    def split_components(self: array[dvec2]) -> Tuple[array[ctypes.c_double], array[ctypes.c_double]]: ...
    @overload
    def split_components(self: array[dvec3]) -> Tuple[array[ctypes.c_double], array[ctypes.c_double], array[ctypes.c_double]]: ...
    @overload
    def split_components(self: array[dvec4]) -> Tuple[array[ctypes.c_double], array[ctypes.c_double], array[ctypes.c_double], array[ctypes.c_double]]: ...
    @overload
    def split_components(self: array[i16vec1]) -> Tuple[array[ctypes.c_short]]: ...
    @overload
    def split_components(self: array[i16vec2]) -> Tuple[array[ctypes.c_short], array[ctypes.c_short]]: ...
    @overload
    def split_components(self: array[i16vec3]) -> Tuple[array[ctypes.c_short], array[ctypes.c_short], array[ctypes.c_short]]: ...
    @overload
    def split_components(self: array[i16vec4]) -> Tuple[array[ctypes.c_short], array[ctypes.c_short], array[ctypes.c_short], array[ctypes.c_short]]: ...
    @overload
    def split_components(self: array[i64vec1]) -> Tuple[array[ctypes.c_longlong]]: ...
    @overload
    def split_components(self: array[i64vec2]) -> Tuple[array[ctypes.c_longlong], array[ctypes.c_longlong]]: ...
    @overload
    def split_components(self: array[i64vec3]) -> Tuple[array[ctypes.c_longlong], array[ctypes.c_longlong], array[ctypes.c_longlong]]: ...
    @overload
    def split_components(self: array[i64vec4]) -> Tuple[array[ctypes.c_longlong], array[ctypes.c_longlong], array[ctypes.c_longlong], array[ctypes.c_longlong]]: ...
    @overload
    def split_components(self: array[i8vec1]) -> Tuple[array[ctypes.c_byte]]: ...
    @overload
    def split_components(self: array[i8vec2]) -> Tuple[array[ctypes.c_byte], array[ctypes.c_byte]]: ...
    @overload
    def split_components(self: array[i8vec3]) -> Tuple[array[ctypes.c_byte], array[ctypes.c_byte], array[ctypes.c_byte]]: ...
    @overload
    def split_components(self: array[i8vec4]) -> Tuple[array[ctypes.c_byte], array[ctypes.c_byte], array[ctypes.c_byte], array[ctypes.c_byte]]: ...
    @overload
    def split_components(self: array[imvec2]) -> Tuple[array[ctypes.c_long], array[ctypes.c_long]]: ...
    @overload
    def split_components(self: array[imvec3]) -> Tuple[array[ctypes.c_long], array[ctypes.c_long], array[ctypes.c_long]]: ...
    @overload
    def split_components(self: array[imvec4]) -> Tuple[array[ctypes.c_long], array[ctypes.c_long], array[ctypes.c_long], array[ctypes.c_long]]: ...
    @overload
    def split_components(self: array[ivec1]) -> Tuple[array[ctypes.c_long]]: ...
    @overload
    def split_components(self: array[ivec2]) -> Tuple[array[ctypes.c_long], array[ctypes.c_long]]: ...
    @overload
    def split_components(self: array[ivec3]) -> Tuple[array[ctypes.c_long], array[ctypes.c_long], array[ctypes.c_long]]: ...
    @overload
    def split_components(self: array[ivec4]) -> Tuple[array[ctypes.c_long], array[ctypes.c_long], array[ctypes.c_long], array[ctypes.c_long]]: ...
    @overload
    def split_components(self: array[mvec2]) -> Tuple[array[ctypes.c_float], array[ctypes.c_float]]: ...
    @overload
    def split_components(self: array[mvec3]) -> Tuple[array[ctypes.c_float], array[ctypes.c_float], array[ctypes.c_float]]: ...
    @overload
    def split_components(self: array[mvec4]) -> Tuple[array[ctypes.c_float], array[ctypes.c_float], array[ctypes.c_float], array[ctypes.c_float]]: ...
    @overload
    def split_components(self: array[u16vec1]) -> Tuple[array[ctypes.c_ushort]]: ...
    @overload
    def split_components(self: array[u16vec2]) -> Tuple[array[ctypes.c_ushort], array[ctypes.c_ushort]]: ...
    @overload
    def split_components(self: array[u16vec3]) -> Tuple[array[ctypes.c_ushort], array[ctypes.c_ushort], array[ctypes.c_ushort]]: ...
    @overload
    def split_components(self: array[u16vec4]) -> Tuple[array[ctypes.c_ushort], array[ctypes.c_ushort], array[ctypes.c_ushort], array[ctypes.c_ushort]]: ...
    @overload
    def split_components(self: array[u64vec1]) -> Tuple[array[ctypes.c_ulonglong]]: ...
    @overload
    def split_components(self: array[u64vec2]) -> Tuple[array[ctypes.c_ulonglong], array[ctypes.c_ulonglong]]: ...
    @overload
    def split_components(self: array[u64vec3]) -> Tuple[array[ctypes.c_ulonglong], array[ctypes.c_ulonglong], array[ctypes.c_ulonglong]]: ...
    @overload
    def split_components(self: array[u64vec4]) -> Tuple[array[ctypes.c_ulonglong], array[ctypes.c_ulonglong], array[ctypes.c_ulonglong], array[ctypes.c_ulonglong]]: ...
    @overload
    def split_components(self: array[u8vec1]) -> Tuple[array[ctypes.c_ubyte]]: ...
    @overload
    def split_components(self: array[u8vec2]) -> Tuple[array[ctypes.c_ubyte], array[ctypes.c_ubyte]]: ...
    @overload
    def split_components(self: array[u8vec3]) -> Tuple[array[ctypes.c_ubyte], array[ctypes.c_ubyte], array[ctypes.c_ubyte]]: ...
    @overload
    def split_components(self: array[u8vec4]) -> Tuple[array[ctypes.c_ubyte], array[ctypes.c_ubyte], array[ctypes.c_ubyte], array[ctypes.c_ubyte]]: ...
    @overload
    def split_components(self: array[umvec2]) -> Tuple[array[ctypes.c_ulong], array[ctypes.c_ulong]]: ...
    @overload
    def split_components(self: array[umvec3]) -> Tuple[array[ctypes.c_ulong], array[ctypes.c_ulong], array[ctypes.c_ulong]]: ...
    @overload
    def split_components(self: array[umvec4]) -> Tuple[array[ctypes.c_ulong], array[ctypes.c_ulong], array[ctypes.c_ulong], array[ctypes.c_ulong]]: ...
    @overload
    def split_components(self: array[uvec1]) -> Tuple[array[ctypes.c_ulong]]: ...
    @overload
    def split_components(self: array[uvec2]) -> Tuple[array[ctypes.c_ulong], array[ctypes.c_ulong]]: ...
    @overload
    def split_components(self: array[uvec3]) -> Tuple[array[ctypes.c_ulong], array[ctypes.c_ulong], array[ctypes.c_ulong]]: ...
    @overload
    def split_components(self: array[uvec4]) -> Tuple[array[ctypes.c_ulong], array[ctypes.c_ulong], array[ctypes.c_ulong], array[ctypes.c_ulong]]: ...
    @overload
    def split_components(self: array[vec1]) -> Tuple[array[ctypes.c_float]]: ...
    @overload
    def split_components(self: array[vec2]) -> Tuple[array[ctypes.c_float], array[ctypes.c_float]]: ...
    @overload
    def split_components(self: array[vec3]) -> Tuple[array[ctypes.c_float], array[ctypes.c_float], array[ctypes.c_float]]: ...
    @overload
    def split_components(self: array[vec4]) -> Tuple[array[ctypes.c_float], array[ctypes.c_float], array[ctypes.c_float], array[ctypes.c_float]]: ...
    @overload
    def split_components(self: array[dquat]) -> Tuple[array[ctypes.c_double], array[ctypes.c_double], array[ctypes.c_double], array[ctypes.c_double]]: ...
    @overload
    def split_components(self: array[quat]) -> Tuple[array[ctypes.c_float], array[ctypes.c_float], array[ctypes.c_float], array[ctypes.c_float]]: ...
    @overload
    def split_components(self: array[dmat2x2]) -> Tuple[array[dvec2], array[dvec2]]: ...
    @overload
    def split_components(self: array[dmat2x3]) -> Tuple[array[dvec3], array[dvec3]]: ...
    @overload
    def split_components(self: array[dmat2x4]) -> Tuple[array[dvec4], array[dvec4]]: ...
    @overload
    def split_components(self: array[dmat3x2]) -> Tuple[array[dvec2], array[dvec2], array[dvec2]]: ...
    @overload
    def split_components(self: array[dmat3x3]) -> Tuple[array[dvec3], array[dvec3], array[dvec3]]: ...
    @overload
    def split_components(self: array[dmat3x4]) -> Tuple[array[dvec4], array[dvec4], array[dvec4]]: ...
    @overload
    def split_components(self: array[dmat4x2]) -> Tuple[array[dvec2], array[dvec2], array[dvec2], array[dvec2]]: ...
    @overload
    def split_components(self: array[dmat4x3]) -> Tuple[array[dvec3], array[dvec3], array[dvec3], array[dvec3]]: ...
    @overload
    def split_components(self: array[dmat4x4]) -> Tuple[array[dvec4], array[dvec4], array[dvec4], array[dvec4]]: ...
    @overload
    def split_components(self: array[imat2x2]) -> Tuple[array[ivec2], array[ivec2]]: ...
    @overload
    def split_components(self: array[imat2x3]) -> Tuple[array[ivec3], array[ivec3]]: ...
    @overload
    def split_components(self: array[imat2x4]) -> Tuple[array[ivec4], array[ivec4]]: ...
    @overload
    def split_components(self: array[imat3x2]) -> Tuple[array[ivec2], array[ivec2], array[ivec2]]: ...
    @overload
    def split_components(self: array[imat3x3]) -> Tuple[array[ivec3], array[ivec3], array[ivec3]]: ...
    @overload
    def split_components(self: array[imat3x4]) -> Tuple[array[ivec4], array[ivec4], array[ivec4]]: ...
    @overload
    def split_components(self: array[imat4x2]) -> Tuple[array[ivec2], array[ivec2], array[ivec2], array[ivec2]]: ...
    @overload
    def split_components(self: array[imat4x3]) -> Tuple[array[ivec3], array[ivec3], array[ivec3], array[ivec3]]: ...
    @overload
    def split_components(self: array[imat4x4]) -> Tuple[array[ivec4], array[ivec4], array[ivec4], array[ivec4]]: ...
    @overload
    def split_components(self: array[mat2x2]) -> Tuple[array[vec2], array[vec2]]: ...
    @overload
    def split_components(self: array[mat2x3]) -> Tuple[array[vec3], array[vec3]]: ...
    @overload
    def split_components(self: array[mat2x4]) -> Tuple[array[vec4], array[vec4]]: ...
    @overload
    def split_components(self: array[mat3x2]) -> Tuple[array[vec2], array[vec2], array[vec2]]: ...
    @overload
    def split_components(self: array[mat3x3]) -> Tuple[array[vec3], array[vec3], array[vec3]]: ...
    @overload
    def split_components(self: array[mat3x4]) -> Tuple[array[vec4], array[vec4], array[vec4]]: ...
    @overload
    def split_components(self: array[mat4x2]) -> Tuple[array[vec2], array[vec2], array[vec2], array[vec2]]: ...
    @overload
    def split_components(self: array[mat4x3]) -> Tuple[array[vec3], array[vec3], array[vec3], array[vec3]]: ...
    @overload
    def split_components(self: array[mat4x4]) -> Tuple[array[vec4], array[vec4], array[vec4], array[vec4]]: ...
    @overload
    def split_components(self: array[umat2x2]) -> Tuple[array[uvec2], array[uvec2]]: ...
    @overload
    def split_components(self: array[umat2x3]) -> Tuple[array[uvec3], array[uvec3]]: ...
    @overload
    def split_components(self: array[umat2x4]) -> Tuple[array[uvec4], array[uvec4]]: ...
    @overload
    def split_components(self: array[umat3x2]) -> Tuple[array[uvec2], array[uvec2], array[uvec2]]: ...
    @overload
    def split_components(self: array[umat3x3]) -> Tuple[array[uvec3], array[uvec3], array[uvec3]]: ...
    @overload
    def split_components(self: array[umat3x4]) -> Tuple[array[uvec4], array[uvec4], array[uvec4]]: ...
    @overload
    def split_components(self: array[umat4x2]) -> Tuple[array[uvec2], array[uvec2], array[uvec2], array[uvec2]]: ...
    @overload
    def split_components(self: array[umat4x3]) -> Tuple[array[uvec3], array[uvec3], array[uvec3], array[uvec3]]: ...
    @overload
    def split_components(self: array[umat4x4]) -> Tuple[array[uvec4], array[uvec4], array[uvec4], array[uvec4]]: ...

    def reduce(self, func: Callable[[_AT, _AT], _AT], init: Optional[_AT] = ..., /) -> _AT: ...
    def filter(self, _: Callable[[_AT], Any], /) -> array[_AT]: ...
    def map(self, _: Callable[[_AT], _AT2], /) -> array[_AT2]: ...
    def sort(self, _: Callable[[_AT], SupportsInt], /) -> array[_AT]: ...
    def concat(self, other: array[_AT], /) -> array[_AT]: ...
    def iconcat(self, other: array[_AT], /) -> None: ...
    def repeat(self, count: int, /) -> array[_AT]: ...
    def irepeat(self, count: int, /) -> None: ...

    @overload
    @staticmethod
    def as_reference(array: array[_AT], /) -> array[_AT]: ...
    @overload
    @staticmethod
    def as_reference(obj: _GLMT, /) -> array[_GLMT]: ...

    def reinterpret_cast(self, type: Type[_AT], /) -> array[_AT]: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def __add__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __iadd__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __sub__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __isub__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __mul__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __imul__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __mod__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __imod__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __pow__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __ipow__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __lshift__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __ilshift__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __rshift__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __irshift__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __and__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __iand__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __xor__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __ixor__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __or__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __ior__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __truediv__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __itruediv__(self, other: Union[glm_typing.Number, _AT, array[_AT]]) -> array[_AT]: ...

    def __neg__(self) -> array[_AT]: ...
    def __pos__(self) -> array[_AT]: ...
    def __abs__(self) -> array[_AT]: ...
    def __inv__(self) -> array[_AT]: ...


@overload
def abs(x: glm_typing.Number, /) -> float: ...
@overload
def abs(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def abs(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def abs(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def abs(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def abs(x: _VT, /) -> _VT: ...

@overload
def ceil(x: glm_typing.Number, /) -> float: ...
@overload
def ceil(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def ceil(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def ceil(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def ceil(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def ceil(x: _VT, /) -> _VT: ...

@overload
def clamp(x: glm_typing.Number, min: glm_typing.Number, max: glm_typing.Number, /) -> glm_typing.Number: ...
@overload
def clamp(x: glm_typing.F32Vector1, min: glm_typing.Number, max: glm_typing.Number, /) -> vec1: ...
@overload
def clamp(x: glm_typing.F32Vector1, min: glm_typing.F32Vector1, max: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def clamp(x: glm_typing.F32Vector2, min: glm_typing.Number, max: glm_typing.Number, /) -> vec2: ...
@overload
def clamp(x: glm_typing.F32Vector2, min: glm_typing.F32Vector2, max: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def clamp(x: glm_typing.F32Vector3, min: glm_typing.Number, max: glm_typing.Number, /) -> vec3: ...
@overload
def clamp(x: glm_typing.F32Vector3, min: glm_typing.F32Vector3, max: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def clamp(x: glm_typing.F32Vector4, min: glm_typing.Number, max: glm_typing.Number, /) -> vec4: ...
@overload
def clamp(x: glm_typing.F32Vector4, min: glm_typing.F32Vector4, max: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def clamp(x: _NF32VT, min: glm_typing.Number, max: glm_typing.Number, /) -> _NF32VT: ...
@overload
def clamp(x: _NF32VT, min: _NF32VT, max: _NF32VT, /) -> _NF32VT: ...

@overload
def floatBitsToInt(x: float, /) -> int: ...
@overload
def floatBitsToInt(x: glm_typing.F32Vector2, /) -> ivec2: ...
@overload
def floatBitsToInt(x: glm_typing.F32Vector3, /) -> ivec3: ...
@overload
def floatBitsToInt(x: glm_typing.F32Vector4, /) -> ivec4: ...
@overload
def floatBitsToInt(x: glm_typing.F32Vector1, /) -> ivec1: ...

@overload
def floatBitsToUint(x: float, /) -> int: ...
@overload
def floatBitsToUint(x: glm_typing.F32Vector2, /) -> uvec2: ...
@overload
def floatBitsToUint(x: glm_typing.F32Vector3, /) -> uvec3: ...
@overload
def floatBitsToUint(x: glm_typing.F32Vector4, /) -> uvec4: ...
@overload
def floatBitsToUint(x: glm_typing.F32Vector1, /) -> uvec1: ...

@overload
def floor(x: glm_typing.Number, /) -> float: ...
@overload
def floor(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def floor(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def floor(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def floor(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def floor(x: _VT, /) -> _VT: ...

def fma(a: glm_typing.Number, b: glm_typing.Number, c: glm_typing.Number, /) -> float: ...

@overload
def fmax(x: glm_typing.Number, y: glm_typing.Number, /) -> float: ...
@overload
def fmax(a: glm_typing.Number, b: glm_typing.Number, c: glm_typing.Number, /) -> float: ...
@overload
def fmax(a: glm_typing.Number, b: glm_typing.Number, c: glm_typing.Number, d: glm_typing.Number, /) -> float: ...
@overload
def fmax(x: glm_typing.F32Vector1, y: glm_typing.Number, /) -> vec1: ...
@overload
def fmax(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def fmax(a: glm_typing.F32Vector1, b: glm_typing.F32Vector1, c: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def fmax(a: glm_typing.F32Vector1, b: glm_typing.F32Vector1, c: glm_typing.F32Vector1, d: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def fmax(x: glm_typing.F32Vector2, y: glm_typing.Number, /) -> vec2: ...
@overload
def fmax(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def fmax(a: glm_typing.F32Vector2, b: glm_typing.F32Vector2, c: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def fmax(a: glm_typing.F32Vector2, b: glm_typing.F32Vector2, c: glm_typing.F32Vector2, d: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def fmax(x: glm_typing.F32Vector3, y: glm_typing.Number, /) -> vec3: ...
@overload
def fmax(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def fmax(a: glm_typing.F32Vector3, b: glm_typing.F32Vector3, c: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def fmax(a: glm_typing.F32Vector3, b: glm_typing.F32Vector3, c: glm_typing.F32Vector3, d: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def fmax(x: glm_typing.F32Vector4, y: glm_typing.Number, /) -> vec4: ...
@overload
def fmax(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def fmax(a: glm_typing.F32Vector4, b: glm_typing.F32Vector4, c: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def fmax(a: glm_typing.F32Vector4, b: glm_typing.F32Vector4, c: glm_typing.F32Vector4, d: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def fmax(x: _NF32VT, y: glm_typing.Number, /) -> _NF32VT: ...
@overload
def fmax(x: _NF32VT, y: _NF32VT, /) -> _NF32VT: ...
@overload
def fmax(a: _NF32VT, b: _NF32VT, c: _NF32VT, /) -> _NF32VT: ...
@overload
def fmax(a: _NF32VT, b: _NF32VT, c: _NF32VT, d: _NF32VT, /) -> _NF32VT: ...

@overload
def fmin(x: glm_typing.Number, y: glm_typing.Number, /) -> float: ...
@overload
def fmin(a: glm_typing.Number, b: glm_typing.Number, c: glm_typing.Number, /) -> float: ...
@overload
def fmin(a: glm_typing.Number, b: glm_typing.Number, c: glm_typing.Number, d: glm_typing.Number, /) -> float: ...
@overload
def fmin(x: glm_typing.F32Vector1, y: glm_typing.Number, /) -> vec1: ...
@overload
def fmin(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def fmin(a: glm_typing.F32Vector1, b: glm_typing.F32Vector1, c: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def fmin(a: glm_typing.F32Vector1, b: glm_typing.F32Vector1, c: glm_typing.F32Vector1, d: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def fmin(x: glm_typing.F32Vector2, y: glm_typing.Number, /) -> vec2: ...
@overload
def fmin(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def fmin(a: glm_typing.F32Vector2, b: glm_typing.F32Vector2, c: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def fmin(a: glm_typing.F32Vector2, b: glm_typing.F32Vector2, c: glm_typing.F32Vector2, d: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def fmin(x: glm_typing.F32Vector3, y: glm_typing.Number, /) -> vec3: ...
@overload
def fmin(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def fmin(a: glm_typing.F32Vector3, b: glm_typing.F32Vector3, c: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def fmin(a: glm_typing.F32Vector3, b: glm_typing.F32Vector3, c: glm_typing.F32Vector3, d: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def fmin(x: glm_typing.F32Vector4, y: glm_typing.Number, /) -> vec4: ...
@overload
def fmin(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def fmin(a: glm_typing.F32Vector4, b: glm_typing.F32Vector4, c: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def fmin(a: glm_typing.F32Vector4, b: glm_typing.F32Vector4, c: glm_typing.F32Vector4, d: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def fmin(x: _NF32VT, y: glm_typing.Number, /) -> _NF32VT: ...
@overload
def fmin(x: _NF32VT, y: _NF32VT, /) -> _NF32VT: ...
@overload
def fmin(a: _NF32VT, b: _NF32VT, c: _NF32VT, /) -> _NF32VT: ...
@overload
def fmin(a: _NF32VT, b: _NF32VT, c: _NF32VT, d: _NF32VT, /) -> _NF32VT: ...

@overload
def fract(x: glm_typing.Number, /) -> float: ...
@overload
def fract(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def fract(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def fract(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def fract(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def fract(x: _VT, /) -> _VT: ...

@overload
def frexp(x: glm_typing.Number, /) -> Tuple[float, int]: ...
@overload
def frexp(x: dvec1, exp: ivec1, /) -> dvec1: ...
@overload
def frexp(x: dvec2, exp: ivec2, /) -> dvec2: ...
@overload
def frexp(x: dvec3, exp: ivec3, /) -> dvec3: ...
@overload
def frexp(x: dvec4, exp: ivec4, /) -> dvec4: ...
@overload
def frexp(x: glm_typing.F32Vector1, exp: ivec1, /) -> vec1: ...
@overload
def frexp(x: glm_typing.F32Vector2, exp: ivec2, /) -> vec2: ...
@overload
def frexp(x: glm_typing.F32Vector3, exp: ivec3, /) -> vec3: ...
@overload
def frexp(x: glm_typing.F32Vector4, exp: ivec4, /) -> vec4: ...

@overload
def intBitsToFloat(x: int, /) -> float: ...
@overload
def intBitsToFloat(x: glm_typing.I32Vector2, /) -> vec2: ...
@overload
def intBitsToFloat(x: glm_typing.I32Vector3, /) -> vec3: ...
@overload
def intBitsToFloat(x: glm_typing.I32Vector4, /) -> vec4: ...
@overload
def intBitsToFloat(x: glm_typing.I32Vector1, /) -> vec1: ...

@overload
def isinf(x: glm_typing.Number, /) -> bool: ...
@overload
def isinf(x: glm_typing.FDAnyVector1, /) -> bvec1: ...
@overload
def isinf(x: glm_typing.FDAnyVector2, /) -> bvec2: ...
@overload
def isinf(x: glm_typing.FDAnyVector3, /) -> bvec3: ...
@overload
def isinf(x: glm_typing.FDAnyQuaternionVector4, /) -> bvec4: ...

@overload
def isnan(x: glm_typing.Number, /) -> bool: ...
@overload
def isnan(x: glm_typing.FDAnyVector1, /) -> bvec1: ...
@overload
def isnan(x: glm_typing.FDAnyVector2, /) -> bvec2: ...
@overload
def isnan(x: glm_typing.FDAnyVector3, /) -> bvec3: ...
@overload
def isnan(x: glm_typing.FDAnyQuaternionVector4, /) -> bvec4: ...

@overload
def ldexp(x: glm_typing.Number, exp: glm_typing.Number, /) -> float: ...
@overload
def ldexp(x: dmvec2, exp: ivec2, /) -> dmvec2: ...
@overload
def ldexp(x: dmvec3, exp: ivec3, /) -> dmvec3: ...
@overload
def ldexp(x: dmvec4, exp: ivec4, /) -> dmvec4: ...
@overload
def ldexp(x: dvec1, exp: ivec1, /) -> dvec1: ...
@overload
def ldexp(x: dvec2, exp: ivec2, /) -> dvec2: ...
@overload
def ldexp(x: dvec3, exp: ivec3, /) -> dvec3: ...
@overload
def ldexp(x: dvec4, exp: ivec4, /) -> dvec4: ...
@overload
def ldexp(x: mvec2, exp: ivec2, /) -> mvec2: ...
@overload
def ldexp(x: mvec3, exp: ivec3, /) -> mvec3: ...
@overload
def ldexp(x: mvec4, exp: ivec4, /) -> mvec4: ...
@overload
def ldexp(x: Union[vec1, Tuple[glm_typing.Number]], exp: ivec1, /) -> vec1: ...
@overload
def ldexp(x: Union[vec2, Tuple[glm_typing.Number, glm_typing.Number]], exp: ivec2, /) -> vec2: ...
@overload
def ldexp(x: Union[vec3, Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number]], exp: ivec3, /) -> vec3: ...
@overload
def ldexp(x: Union[vec4, Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number]], exp: ivec4, /) -> vec4: ...

@overload
def max(x: glm_typing.Number, y: glm_typing.Number, /) -> float: ...
@overload
def max(a: glm_typing.Number, b: glm_typing.Number, c: glm_typing.Number, /) -> float: ...
@overload
def max(a: glm_typing.Number, b: glm_typing.Number, c: glm_typing.Number, d: glm_typing.Number, /) -> float: ...
@overload
def max(x: glm_typing.F32Vector1, y: glm_typing.Number, /) -> vec1: ...
@overload
def max(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def max(a: glm_typing.F32Vector1, b: glm_typing.F32Vector1, c: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def max(a: glm_typing.F32Vector1, b: glm_typing.F32Vector1, c: glm_typing.F32Vector1, d: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def max(x: glm_typing.F32Vector2, y: glm_typing.Number, /) -> vec2: ...
@overload
def max(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def max(a: glm_typing.F32Vector2, b: glm_typing.F32Vector2, c: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def max(a: glm_typing.F32Vector2, b: glm_typing.F32Vector2, c: glm_typing.F32Vector2, d: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def max(x: glm_typing.F32Vector3, y: glm_typing.Number, /) -> vec3: ...
@overload
def max(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def max(a: glm_typing.F32Vector3, b: glm_typing.F32Vector3, c: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def max(a: glm_typing.F32Vector3, b: glm_typing.F32Vector3, c: glm_typing.F32Vector3, d: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def max(x: glm_typing.F32Vector4, y: glm_typing.Number, /) -> vec4: ...
@overload
def max(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def max(a: glm_typing.F32Vector4, b: glm_typing.F32Vector4, c: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def max(a: glm_typing.F32Vector4, b: glm_typing.F32Vector4, c: glm_typing.F32Vector4, d: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def max(x: _NF32VT, y: glm_typing.Number, /) -> _NF32VT: ...
@overload
def max(x: _NF32VT, y: _NF32VT, /) -> _NF32VT: ...
@overload
def max(a: _NF32VT, b: _NF32VT, c: _NF32VT, /) -> _NF32VT: ...
@overload
def max(a: _NF32VT, b: _NF32VT, c: _NF32VT, d: _NF32VT, /) -> _NF32VT: ...
@overload
def max(_: Iterable[_T], /) -> _T: ...

@overload
def min(x: glm_typing.Number, y: glm_typing.Number, /) -> float: ...
@overload
def min(a: glm_typing.Number, b: glm_typing.Number, c: glm_typing.Number, /) -> float: ...
@overload
def min(a: glm_typing.Number, b: glm_typing.Number, c: glm_typing.Number, d: glm_typing.Number, /) -> float: ...
@overload
def min(x: glm_typing.F32Vector1, y: glm_typing.Number, /) -> vec1: ...
@overload
def min(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def min(a: glm_typing.F32Vector1, b: glm_typing.F32Vector1, c: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def min(a: glm_typing.F32Vector1, b: glm_typing.F32Vector1, c: glm_typing.F32Vector1, d: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def min(x: glm_typing.F32Vector2, y: glm_typing.Number, /) -> vec2: ...
@overload
def min(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def min(a: glm_typing.F32Vector2, b: glm_typing.F32Vector2, c: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def min(a: glm_typing.F32Vector2, b: glm_typing.F32Vector2, c: glm_typing.F32Vector2, d: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def min(x: glm_typing.F32Vector3, y: glm_typing.Number, /) -> vec3: ...
@overload
def min(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def min(a: glm_typing.F32Vector3, b: glm_typing.F32Vector3, c: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def min(a: glm_typing.F32Vector3, b: glm_typing.F32Vector3, c: glm_typing.F32Vector3, d: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def min(x: glm_typing.F32Vector4, y: glm_typing.Number, /) -> vec4: ...
@overload
def min(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def min(a: glm_typing.F32Vector4, b: glm_typing.F32Vector4, c: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def min(a: glm_typing.F32Vector4, b: glm_typing.F32Vector4, c: glm_typing.F32Vector4, d: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def min(x: _NF32VT, y: glm_typing.Number, /) -> _NF32VT: ...
@overload
def min(x: _NF32VT, y: _NF32VT, /) -> _NF32VT: ...
@overload
def min(a: _NF32VT, b: _NF32VT, c: _NF32VT, /) -> _NF32VT: ...
@overload
def min(a: _NF32VT, b: _NF32VT, c: _NF32VT, d: _NF32VT, /) -> _NF32VT: ...
@overload
def min(_: Iterable[_T], /) -> _T: ...

@overload
def mix(x: glm_typing.Number, y: glm_typing.Number, a: glm_typing.Number, /) -> float: ...
@overload
def mix(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, a: Union[glm_typing.FDAnyVector1, glm_typing.BAnyVector1, glm_typing.Number], /) -> vec1: ...
@overload
def mix(x: _NF32V1T, y: _NF32V1T, a: Union[glm_typing.FDAnyVector1, glm_typing.BAnyVector1, glm_typing.Number], /) -> _NF32V1T: ...
@overload
def mix(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, a: Union[glm_typing.FDAnyVector2, glm_typing.BAnyVector2, glm_typing.Number], /) -> vec2: ...
@overload
def mix(x: _NF32V2T, y: _NF32V2T, a: Union[glm_typing.FDAnyVector2, glm_typing.BAnyVector2, glm_typing.Number], /) -> _NF32V2T: ...
@overload
def mix(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, a: Union[glm_typing.FDAnyVector3, glm_typing.BAnyVector3, glm_typing.Number], /) -> vec3: ...
@overload
def mix(x: _NF32V3T, y: _NF32V3T, a: Union[glm_typing.FDAnyVector3, glm_typing.BAnyVector3, glm_typing.Number], /) -> _NF32V3T: ...
@overload
def mix(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, a: Union[glm_typing.FDAnyVector4, glm_typing.BAnyVector4, glm_typing.Number], /) -> vec4: ...
@overload
def mix(x: _NF32V4T, y: _NF32V4T, a: Union[glm_typing.FDAnyVector4, glm_typing.BAnyVector4, glm_typing.Number], /) -> _NF32V4T: ...
@overload
def mix(x: glm_typing.F32Matrix2x2, y: glm_typing.F32Matrix2x2, a: Union[glm_typing.FAnyMatrix2x2, glm_typing.Number], /) -> mat2x2: ...
@overload
def mix(x: _NF32M2X2T, y: _NF32M2X2T, a: Union[glm_typing.FAnyMatrix2x2, glm_typing.Number], /) -> _NF32M2X2T: ...
@overload
def mix(x: glm_typing.F32Matrix2x3, y: glm_typing.F32Matrix2x3, a: Union[glm_typing.FAnyMatrix2x3, glm_typing.Number], /) -> mat2x3: ...
@overload
def mix(x: _NF32M2X3T, y: _NF32M2X3T, a: Union[glm_typing.FAnyMatrix2x3, glm_typing.Number], /) -> _NF32M2X3T: ...
@overload
def mix(x: glm_typing.F32Matrix2x4, y: glm_typing.F32Matrix2x4, a: Union[glm_typing.FAnyMatrix2x4, glm_typing.Number], /) -> mat2x4: ...
@overload
def mix(x: _NF32M2X4T, y: _NF32M2X4T, a: Union[glm_typing.FAnyMatrix2x4, glm_typing.Number], /) -> _NF32M2X4T: ...
@overload
def mix(x: glm_typing.F32Matrix3x2, y: glm_typing.F32Matrix3x2, a: Union[glm_typing.FAnyMatrix3x2, glm_typing.Number], /) -> mat3x2: ...
@overload
def mix(x: _NF32M3X2T, y: _NF32M3X2T, a: Union[glm_typing.FAnyMatrix3x2, glm_typing.Number], /) -> _NF32M3X2T: ...
@overload
def mix(x: glm_typing.F32Matrix3x3, y: glm_typing.F32Matrix3x3, a: Union[glm_typing.FAnyMatrix3x3, glm_typing.Number], /) -> mat3x3: ...
@overload
def mix(x: _NF32M3X3T, y: _NF32M3X3T, a: Union[glm_typing.FAnyMatrix3x3, glm_typing.Number], /) -> _NF32M3X3T: ...
@overload
def mix(x: glm_typing.F32Matrix3x4, y: glm_typing.F32Matrix3x4, a: Union[glm_typing.FAnyMatrix3x4, glm_typing.Number], /) -> mat3x4: ...
@overload
def mix(x: _NF32M3X4T, y: _NF32M3X4T, a: Union[glm_typing.FAnyMatrix3x4, glm_typing.Number], /) -> _NF32M3X4T: ...
@overload
def mix(x: glm_typing.F32Matrix4x2, y: glm_typing.F32Matrix4x2, a: Union[glm_typing.FAnyMatrix4x2, glm_typing.Number], /) -> mat4x2: ...
@overload
def mix(x: _NF32M4X2T, y: _NF32M4X2T, a: Union[glm_typing.FAnyMatrix4x2, glm_typing.Number], /) -> _NF32M4X2T: ...
@overload
def mix(x: glm_typing.F32Matrix4x3, y: glm_typing.F32Matrix4x3, a: Union[glm_typing.FAnyMatrix4x3, glm_typing.Number], /) -> mat4x3: ...
@overload
def mix(x: _NF32M4X3T, y: _NF32M4X3T, a: Union[glm_typing.FAnyMatrix4x3, glm_typing.Number], /) -> _NF32M4X3T: ...
@overload
def mix(x: glm_typing.F32Matrix4x4, y: glm_typing.F32Matrix4x4, a: Union[glm_typing.FAnyMatrix4x4, glm_typing.Number], /) -> mat4x4: ...
@overload
def mix(x: _NF32M4X4T, y: _NF32M4X4T, a: Union[glm_typing.FAnyMatrix4x4, glm_typing.Number], /) -> _NF32M4X4T: ...
@overload
def mix(x: _QT, y: _QT, a: glm_typing.Number, /) -> _QT: ...

@overload
def modf(x: glm_typing.Number, /) -> Tuple[float, float]: ...
@overload
def modf(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def modf(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def modf(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def modf(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def modf(x: _FDVT, i: _FDVT, /) -> _FDVT: ...

@overload
def round(x: glm_typing.Number, /) -> float: ...
@overload
def round(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def round(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def round(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def round(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def round(x: _FDVT, i: _FDVT, /) -> _FDVT: ...

@overload
def roundEven(x: glm_typing.Number, /) -> float: ...
@overload
def roundEven(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def roundEven(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def roundEven(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def roundEven(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def roundEven(x: _FDVT, i: _FDVT, /) -> _FDVT: ...

@overload
def sign(x: glm_typing.Number, /) -> float: ...
@overload
def sign(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def sign(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def sign(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def sign(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def sign(x: _FDVT, i: _FDVT, /) -> _FDVT: ...

@overload
def smoothstep(edge0: glm_typing.Number, edge1: glm_typing.Number, x: glm_typing.Number, /) -> float: ...
@overload
def smoothstep(edge0: glm_typing.Number, edge1: glm_typing.Number, x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def smoothstep(edge0: glm_typing.F32Vector1, edge1: glm_typing.F32Vector1, x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def smoothstep(edge0: glm_typing.Number, edge1: glm_typing.Number, x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def smoothstep(edge0: glm_typing.F32Vector2, edge1: glm_typing.F32Vector2, x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def smoothstep(edge0: glm_typing.Number, edge1: glm_typing.Number, x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def smoothstep(edge0: glm_typing.F32Vector3, edge1: glm_typing.F32Vector3, x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def smoothstep(edge0: glm_typing.Number, edge1: glm_typing.Number, x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def smoothstep(edge0: glm_typing.F32Vector4, edge1: glm_typing.F32Vector4, x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def smoothstep(edge0: glm_typing.Number, edge1: glm_typing.Number, x: _NF32VT, /) -> _FDVT: ...
@overload
def smoothstep(edge0: _NF32VT, edge1: _NF32VT, x: _NF32VT, /) -> _NF32VT: ...

@overload
def step(edge: glm_typing.Number, x: glm_typing.Number, /) -> float: ...
@overload
def step(edge: glm_typing.Number, x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def step(edge: glm_typing.F32Vector1, x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def step(edge: glm_typing.Number, x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def step(edge: glm_typing.F32Vector2, x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def step(edge: glm_typing.Number, x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def step(edge: glm_typing.F32Vector3, x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def step(edge: glm_typing.Number, x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def step(edge: glm_typing.F32Vector4, x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def step(edge: glm_typing.Number, x: _NF32VT, /) -> _NF32VT: ...
@overload
def step(edge: _NF32VT, x: _NF32VT, /) -> _NF32VT: ...

@overload
def trunc(x: glm_typing.Number, /) -> float: ...
@overload
def trunc(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def trunc(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def trunc(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def trunc(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def trunc(x: _FDVT, /) -> _FDVT: ...

@overload
def uintBitsToFloat(x: int, /) -> float: ...
@overload
def uintBitsToFloat(x: glm_typing.U32Vector2, /) -> vec2: ...
@overload
def uintBitsToFloat(x: glm_typing.U32Vector3, /) -> vec3: ...
@overload
def uintBitsToFloat(x: glm_typing.U32Vector4, /) -> vec4: ...
@overload
def uintBitsToFloat(x: glm_typing.U32Vector1, /) -> vec1: ...


@overload
def exp(x: glm_typing.Number, /) -> float: ...
@overload
def exp(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def exp(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def exp(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def exp(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def exp(x: _FDVT, /) -> _FDVT: ...
@overload
def exp(x: _QT, /) -> _QT: ...

@overload
def exp2(x: glm_typing.Number, /) -> float: ...
@overload
def exp2(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def exp2(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def exp2(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def exp2(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def exp2(x: _FDVT, /) -> _FDVT: ...

@overload
def inversesqrt(x: glm_typing.Number, /) -> float: ...
@overload
def inversesqrt(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def inversesqrt(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def inversesqrt(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def inversesqrt(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def inversesqrt(x: _FDVT, /) -> _FDVT: ...

@overload
def log(x: glm_typing.Number, /) -> float: ...
@overload
def log(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def log(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def log(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def log(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def log(x: _FDVT, /) -> _FDVT: ...
@overload
def log(x: _QT, /) -> _QT: ...

@overload
def log2(x: glm_typing.Number, /) -> float: ...
@overload
def log2(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def log2(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def log2(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def log2(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def log2(x: _FDVT, /) -> _FDVT: ...

@overload
def pow(base: glm_typing.Number, exponent: glm_typing.Number, /) -> float: ...
@overload
def pow(base: glm_typing.F32Vector1, exponent: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def pow(base: glm_typing.F32Vector2, exponent: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def pow(base: glm_typing.F32Vector3, exponent: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def pow(base: glm_typing.F32Vector4, exponent: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def pow(base: _NF32DFVT, exponent: _NF32DFVT, /) -> _NF32DFVT: ...
@overload
def pow(base: _QT, exponent: _QT, /) -> _QT: ...

@overload
def sqrt(x: glm_typing.Number, /) -> float: ...
@overload
def sqrt(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def sqrt(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def sqrt(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def sqrt(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def sqrt(x: _FDVT, /) -> _FDVT: ...
@overload
def sqrt(x: _QT, /) -> _QT: ...


@overload
def cross(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def cross(x: _NF32DFV3T, y: _NF32DFV3T, /) -> _NF32DFV3T: ...
@overload
def cross(x: _QT, y: _QT, /) -> _QT: ...

@overload
def distance(p0: glm_typing.Number, p1: glm_typing.Number, /) -> float: ...
@overload
def distance(p0: glm_typing.F32Vector1, p1: glm_typing.F32Vector1, /) -> float: ...
@overload
def distance(p0: glm_typing.F32Vector2, p1: glm_typing.F32Vector2, /) -> float: ...
@overload
def distance(p0: glm_typing.F32Vector3, p1: glm_typing.F32Vector3, /) -> float: ...
@overload
def distance(p0: glm_typing.F32Vector4, p1: glm_typing.F32Vector4, /) -> float: ...
@overload
def distance(p0: _NF32DFVT, p1: _NF32DFVT, /) -> float: ...

@overload
def dot(x: glm_typing.Number, y: glm_typing.Number, /) -> float: ...
@overload
def dot(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, /) -> float: ...
@overload
def dot(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, /) -> float: ...
@overload
def dot(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, /) -> float: ...
@overload
def dot(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, /) -> float: ...
@overload
def dot(x: _NF32DFVT, y: _NF32DFVT, /) -> float: ...
@overload
def dot(x: _QT, y: _QT, /) -> float: ...

@overload
def faceforward(N: glm_typing.Number, I: glm_typing.Number, Nref: float, /) -> float: ...
@overload
def faceforward(x: glm_typing.F32Vector1, I: glm_typing.F32Vector1, Nref: glm_typing.F32Vector1, /) -> float: ...
@overload
def faceforward(x: glm_typing.F32Vector2, I: glm_typing.F32Vector2, Nref: glm_typing.F32Vector2, /) -> float: ...
@overload
def faceforward(x: glm_typing.F32Vector3, I: glm_typing.F32Vector3, Nref: glm_typing.F32Vector3, /) -> float: ...
@overload
def faceforward(x: glm_typing.F32Vector4, I: glm_typing.F32Vector4, Nref: glm_typing.F32Vector4, /) -> float: ...
@overload
def faceforward(N: _NF32DFVT, I: _NF32DFVT, Nref: _NF32DFVT, /) -> _NF32DFVT: ...

def length(x: Union[glm_typing.Number, glm_typing.FDAnyVectorAny, glm_typing.FDAnyQuaternion], /) -> float: ...

@overload
def normalize(x: Tuple[glm_typing.Number], /) -> vec1: ...
@overload
def normalize(x: Tuple[glm_typing.Number, glm_typing.Number], /) -> vec2: ...
@overload
def normalize(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec3: ...
@overload
def normalize(x: Tuple[glm_typing.Number, glm_typing.Number, glm_typing.Number, glm_typing.Number], /) -> vec4: ...
@overload
def normalize(x: _FDVT, /) -> _FDVT: ...
@overload
def normalize(x: _QT, /) -> _QT: ...

@overload
def reflect(I: glm_typing.Number, N: glm_typing.Number, /) -> float: ...
@overload
def reflect(I: glm_typing.F32Vector1, N: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def reflect(I: glm_typing.F32Vector2, N: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def reflect(I: glm_typing.F32Vector3, N: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def reflect(I: glm_typing.F32Vector4, N: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def reflect(I: _NF32DFVT, N: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def refract(I: glm_typing.Number, N: glm_typing.Number, eta: float, /) -> float: ...
@overload
def refract(I: glm_typing.F32Vector1, N: glm_typing.F32Vector1, eta: float, /) -> vec1: ...
@overload
def refract(I: glm_typing.F32Vector2, N: glm_typing.F32Vector2, eta: float, /) -> vec2: ...
@overload
def refract(I: glm_typing.F32Vector3, N: glm_typing.F32Vector3, eta: float, /) -> vec3: ...
@overload
def refract(I: glm_typing.F32Vector4, N: glm_typing.F32Vector4, eta: float, /) -> vec4: ...
@overload
def refract(I: _NF32DFVT, N: _NF32DFVT, eta: float, /) -> _NF32DFVT: ...


@overload
def bitCount(v: int, /) -> int: ...
@overload
def bitCount(v: glm_typing.IUAnyVector1, /) -> ivec1: ...
@overload
def bitCount(v: glm_typing.IUAnyVector2, /) -> ivec2: ...
@overload
def bitCount(v: glm_typing.IUAnyVector3, /) -> ivec3: ...
@overload
def bitCount(v: glm_typing.IUAnyVector4, /) -> ivec4: ...

@overload
def bitfieldExtract(value: int, offset: int, bits: int, /) -> int: ...
@overload
def bitfieldExtract(v: glm_typing.I32Vector1, offset: int, bits: int, /) -> ivec1: ...
@overload
def bitfieldExtract(v: glm_typing.I32Vector2, offset: int, bits: int, /) -> ivec2: ...
@overload
def bitfieldExtract(v: glm_typing.I32Vector3, offset: int, bits: int, /) -> ivec3: ...
@overload
def bitfieldExtract(v: glm_typing.I32Vector4, offset: int, bits: int, /) -> ivec4: ...
@overload
def bitfieldExtract(value: _NI32IUVT, offset: int, bits: int, /) -> _NI32IUVT: ...

@overload
def bitfieldInsert(base: int, insert: int, offset: int, bits: int, /) -> int: ...
@overload
def bitfieldInsert(base: glm_typing.I32Vector1, insert: glm_typing.I32Vector1, offset: int, bits: int, /) -> ivec1: ...
@overload
def bitfieldInsert(base: glm_typing.I32Vector2, insert: glm_typing.I32Vector2, offset: int, bits: int, /) -> ivec2: ...
@overload
def bitfieldInsert(base: glm_typing.I32Vector3, insert: glm_typing.I32Vector3, offset: int, bits: int, /) -> ivec3: ...
@overload
def bitfieldInsert(base: glm_typing.I32Vector4, insert: glm_typing.I32Vector4, offset: int, bits: int, /) -> ivec4: ...
@overload
def bitfieldInsert(base: _NI32IUVT, insert: _NI32IUVT, offset: int, bits: int, /) -> _NI32IUVT: ...

@overload
def bitfieldReverse(value: int, /) -> int: ...
@overload
def bitfieldReverse(value: glm_typing.I32Vector1, /) -> ivec1: ...
@overload
def bitfieldReverse(value: glm_typing.I32Vector2, /) -> ivec2: ...
@overload
def bitfieldReverse(value: glm_typing.I32Vector3, /) -> ivec3: ...
@overload
def bitfieldReverse(value: glm_typing.I32Vector4, /) -> ivec4: ...
@overload
def bitfieldReverse(value: _NI32IUVT, /) -> _NI32IUVT: ...

@overload
def findLSB(value: int, /) -> int: ...
@overload
def findLSB(value: glm_typing.I32Vector1, /) -> ivec1: ...
@overload
def findLSB(value: glm_typing.I32Vector2, /) -> ivec2: ...
@overload
def findLSB(value: glm_typing.I32Vector3, /) -> ivec3: ...
@overload
def findLSB(value: glm_typing.I32Vector4, /) -> ivec4: ...
@overload
def findLSB(value: _NI32IUVT, /) -> _NI32IUVT: ...

@overload
def findMSB(value: int, /) -> int: ...
@overload
def findMSB(value: glm_typing.I32Vector1, /) -> ivec1: ...
@overload
def findMSB(value: glm_typing.I32Vector2, /) -> ivec2: ...
@overload
def findMSB(value: glm_typing.I32Vector3, /) -> ivec3: ...
@overload
def findMSB(value: glm_typing.I32Vector4, /) -> ivec4: ...
@overload
def findMSB(value: _NI32IUVT, /) -> _NI32IUVT: ...

def imulExtended(x: _IVT, y: _IVT, msb: _IVT, lsb: _IVT, /) -> None: ...

def uaddCarry(x: _UVT, y: _UVT, carry: _UVT, /) -> _UVT: ...

def umulExtended(x: _UVT, y: _UVT, msb: _UVT, lsb: _UVT, /) -> None: ...

def usubBorrow(x: _UVT, y: _UVT, borrow: _UVT, /) -> _UVT: ...


def determinant(m: glm_typing.AnyAnyMatrixSquare, /) -> float: ...

@overload
def inverse(m: glm_typing.F32Matrix2x2, /) -> mat2x2: ...
@overload
def inverse(m: glm_typing.F32Matrix3x3, /) -> mat3x3: ...
@overload
def inverse(m: glm_typing.F32Matrix4x4, /) -> mat4x4: ...
@overload
def inverse(m: _NF32FDMSQRT, /) -> _NF32FDMSQRT: ...
@overload
def inverse(q: _QT, /) -> _QT: ...

@overload
def matrixCompMult(x: glm_typing.F32Matrix2x2, y: glm_typing.F32Matrix2x2, /) -> mat2x2: ...
@overload
def matrixCompMult(x: glm_typing.F32Matrix3x3, y: glm_typing.F32Matrix3x3, /) -> mat3x3: ...
@overload
def matrixCompMult(x: glm_typing.F32Matrix4x4, y: glm_typing.F32Matrix4x4, /) -> mat4x4: ...
@overload
def matrixCompMult(x: _NF32FDMSQRT, y: _NF32FDMSQRT, /) -> _NF32FDMSQRT: ...

@overload
def outerProduct(c: glm_typing.F32Vector2, r: glm_typing.F32Vector2, /) -> mat2x2: ...
@overload
def outerProduct(c: dvec2, r: dvec2, /) -> mat2x2: ...
@overload
def outerProduct(c: glm_typing.F32Vector2, r: glm_typing.F32Vector3, /) -> mat3x2: ...
@overload
def outerProduct(c: dvec2, r: dvec3, /) -> mat3x2: ...
@overload
def outerProduct(c: glm_typing.F32Vector2, r: glm_typing.F32Vector4, /) -> mat4x2: ...
@overload
def outerProduct(c: dvec2, r: dvec4, /) -> mat4x2: ...
@overload
def outerProduct(c: glm_typing.F32Vector3, r: glm_typing.F32Vector2, /) -> mat2x3: ...
@overload
def outerProduct(c: dvec3, r: dvec2, /) -> mat2x3: ...
@overload
def outerProduct(c: glm_typing.F32Vector3, r: glm_typing.F32Vector3, /) -> mat3x3: ...
@overload
def outerProduct(c: dvec3, r: dvec3, /) -> mat3x3: ...
@overload
def outerProduct(c: glm_typing.F32Vector3, r: glm_typing.F32Vector4, /) -> mat4x3: ...
@overload
def outerProduct(c: dvec3, r: dvec4, /) -> mat4x3: ...
@overload
def outerProduct(c: glm_typing.F32Vector4, r: glm_typing.F32Vector2, /) -> mat2x4: ...
@overload
def outerProduct(c: dvec4, r: dvec2, /) -> mat2x4: ...
@overload
def outerProduct(c: glm_typing.F32Vector4, r: glm_typing.F32Vector3, /) -> mat3x4: ...
@overload
def outerProduct(c: dvec4, r: dvec3, /) -> mat3x4: ...
@overload
def outerProduct(c: glm_typing.F32Vector4, r: glm_typing.F32Vector4, /) -> mat4x4: ...
@overload
def outerProduct(c: dvec4, r: dvec4, /) -> mat4x4: ...

@overload
def transpose(x: glm_typing.F32Matrix2x2, /) -> fmat2x2: ...
@overload
def transpose(x: glm_typing.F32Matrix2x3, /) -> fmat3x2: ...
@overload
def transpose(x: glm_typing.F32Matrix2x4, /) -> fmat4x2: ...
@overload
def transpose(x: glm_typing.F32Matrix3x2, /) -> fmat2x3: ...
@overload
def transpose(x: glm_typing.F32Matrix3x3, /) -> fmat3x3: ...
@overload
def transpose(x: glm_typing.F32Matrix3x4, /) -> fmat4x3: ...
@overload
def transpose(x: glm_typing.F32Matrix4x2, /) -> fmat2x4: ...
@overload
def transpose(x: glm_typing.F32Matrix4x3, /) -> fmat3x4: ...
@overload
def transpose(x: glm_typing.F32Matrix4x4, /) -> fmat4x4: ...
@overload
def transpose(x: dmat2x2, /) -> dmat2x2: ...
@overload
def transpose(x: dmat2x3, /) -> dmat3x2: ...
@overload
def transpose(x: dmat2x4, /) -> dmat4x2: ...
@overload
def transpose(x: dmat3x2, /) -> dmat2x3: ...
@overload
def transpose(x: dmat3x3, /) -> dmat3x3: ...
@overload
def transpose(x: dmat3x4, /) -> dmat4x3: ...
@overload
def transpose(x: dmat4x2, /) -> dmat2x4: ...
@overload
def transpose(x: dmat4x3, /) -> dmat3x4: ...
@overload
def transpose(x: dmat4x4, /) -> dmat4x4: ...
@overload
def transpose(x: imat2x2, /) -> imat2x2: ...
@overload
def transpose(x: imat2x3, /) -> imat3x2: ...
@overload
def transpose(x: imat2x4, /) -> imat4x2: ...
@overload
def transpose(x: imat3x2, /) -> imat2x3: ...
@overload
def transpose(x: imat3x3, /) -> imat3x3: ...
@overload
def transpose(x: imat3x4, /) -> imat4x3: ...
@overload
def transpose(x: imat4x2, /) -> imat2x4: ...
@overload
def transpose(x: imat4x3, /) -> imat3x4: ...
@overload
def transpose(x: imat4x4, /) -> imat4x4: ...
@overload
def transpose(x: umat2x2, /) -> umat2x2: ...
@overload
def transpose(x: umat2x3, /) -> umat3x2: ...
@overload
def transpose(x: umat2x4, /) -> umat4x2: ...
@overload
def transpose(x: umat3x2, /) -> umat2x3: ...
@overload
def transpose(x: umat3x3, /) -> umat3x3: ...
@overload
def transpose(x: umat3x4, /) -> umat4x3: ...
@overload
def transpose(x: umat4x2, /) -> umat2x4: ...
@overload
def transpose(x: umat4x3, /) -> umat3x4: ...
@overload
def transpose(x: umat4x4, /) -> umat4x4: ...


def packDouble2x32(v: glm_typing.U32Vector2, /) -> float: ...

def packHalf2x16(v: glm_typing.F32Vector2, /) -> int: ...

def packSnorm2x16(v: glm_typing.F32Vector2, /) -> int: ...

def packSnorm4x8(v: glm_typing.F32Vector4, /) -> int: ...

def packUnorm2x16(v: glm_typing.F32Vector2, /) -> int: ...

def packUnorm4x8(v: glm_typing.F32Vector4, /) -> int: ...

def unpackDouble2x32(v: float, /) -> uvec2: ...

def unpackHalf2x16(v: int, /) -> vec2: ...

def unpackSnorm2x16(p: int, /) -> vec2: ...

def unpackSnorm4x8(p: int, /) -> vec4: ...

def unpackUnorm2x16(p: int, /) -> vec2: ...

def unpackUnorm4x8(p: int, /) -> vec4: ...


@overload
def acos(x: glm_typing.Number, /) -> float: ...
@overload
def acos(x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def acos(x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def acos(x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def acos(x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def acos(x: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def acosh(x: glm_typing.Number, /) -> float: ...
@overload
def acosh(x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def acosh(x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def acosh(x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def acosh(x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def acosh(x: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def asin(x: glm_typing.Number, /) -> float: ...
@overload
def asin(x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def asin(x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def asin(x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def asin(x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def asin(x: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def asinh(x: glm_typing.Number, /) -> float: ...
@overload
def asinh(x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def asinh(x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def asinh(x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def asinh(x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def asinh(x: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def atan(y_over_x: glm_typing.Number, /) -> float: ...
@overload
def atan(y_over_x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def atan(y_over_x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def atan(y_over_x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def atan(y_over_x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def atan(y_over_x: _NF32DFVT, /) -> _NF32DFVT: ...
@overload
def atan(y: glm_typing.Number, x: glm_typing.Number, /) -> float: ...
@overload
def atan(y: glm_typing.F32Vector1, x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def atan(y: glm_typing.F32Vector2, x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def atan(y: glm_typing.F32Vector3, x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def atan(y: glm_typing.F32Vector4, x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def atan(y: _NF32DFVT, x: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def atanh(x: glm_typing.Number, /) -> float: ...
@overload
def atanh(x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def atanh(x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def atanh(x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def atanh(x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def atanh(x: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def cos(x: glm_typing.Number, /) -> float: ...
@overload
def cos(x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def cos(x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def cos(x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def cos(x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def cos(x: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def cosh(x: glm_typing.Number, /) -> float: ...
@overload
def cosh(x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def cosh(x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def cosh(x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def cosh(x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def cosh(x: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def degrees(x: glm_typing.Number, /) -> float: ...
@overload
def degrees(x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def degrees(x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def degrees(x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def degrees(x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def degrees(x: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def radians(x: glm_typing.Number, /) -> float: ...
@overload
def radians(x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def radians(x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def radians(x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def radians(x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def radians(x: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def sin(x: glm_typing.Number, /) -> float: ...
@overload
def sin(x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def sin(x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def sin(x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def sin(x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def sin(x: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def sinh(x: glm_typing.Number, /) -> float: ...
@overload
def sinh(x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def sinh(x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def sinh(x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def sinh(x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def sinh(x: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def tan(x: glm_typing.Number, /) -> float: ...
@overload
def tan(x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def tan(x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def tan(x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def tan(x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def tan(x: _NF32DFVT, /) -> _NF32DFVT: ...

@overload
def tanh(x: glm_typing.Number, /) -> float: ...
@overload
def tanh(x: glm_typing.F32Vector1, /) -> vec1: ...
@overload
def tanh(x: glm_typing.F32Vector2, /) -> vec2: ...
@overload
def tanh(x: glm_typing.F32Vector3, /) -> vec3: ...
@overload
def tanh(x: glm_typing.F32Vector4, /) -> vec4: ...
@overload
def tanh(x: _NF32DFVT, /) -> _NF32DFVT: ...



def all(v: glm_typing.BAnyVectorAny, /) -> bool: ...

def any(v: glm_typing.BAnyVectorAny, /) -> bool: ...

@overload
def equal(x: glm_typing.Number, y: glm_typing.Number, ULPs: int, /) -> int: ...
@overload
def equal(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, /) -> bvec1: ...
@overload
def equal(x: _NF32V1T, y: _NF32V1T, /) -> bvec1: ...
@overload
def equal(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, ULPs_epsilon: Union[glm_typing.Number, ivec1, glm_typing.F32Vector1], /) -> bvec1: ...
@overload
def equal(x: _NF32V1T, y: _NF32V1T, ULPs_epsilon: Union[glm_typing.Number, ivec1, glm_typing.F32Vector1], /) -> bvec1: ...
@overload
def equal(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, /) -> bvec2: ...
@overload
def equal(x: _NF32V2T, y: _NF32V2T, /) -> bvec2: ...
@overload
def equal(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, ULPs_epsilon: Union[glm_typing.Number, ivec2, glm_typing.F32Vector2], /) -> bvec2: ...
@overload
def equal(x: _NF32V2T, y: _NF32V2T, ULPs_epsilon: Union[glm_typing.Number, ivec2, glm_typing.F32Vector2], /) -> bvec2: ...
@overload
def equal(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, /) -> bvec3: ...
@overload
def equal(x: _NF32V3T, y: _NF32V3T, /) -> bvec3: ...
@overload
def equal(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, ULPs_epsilon: Union[glm_typing.Number, ivec3, glm_typing.F32Vector3], /) -> bvec3: ...
@overload
def equal(x: _NF32V3T, y: _NF32V3T, ULPs_epsilon: Union[glm_typing.Number, ivec3, glm_typing.F32Vector3], /) -> bvec3: ...
@overload
def equal(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, /) -> bvec4: ...
@overload
def equal(x: _NF32V4T, y: _NF32V4T, /) -> bvec4: ...
@overload
def equal(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, ULPs_epsilon: Union[glm_typing.Number, ivec4, glm_typing.F32Vector4], /) -> bvec4: ...
@overload
def equal(x: _NF32V4T, y: _NF32V4T, ULPs_epsilon: Union[glm_typing.Number, ivec4, glm_typing.F32Vector4], /) -> bvec4: ...
@overload
def equal(x: glm_typing.F32Matrix2xAny, y: glm_typing.F32Matrix2xAny, /) -> bvec2: ...
@overload
def equal(x: _NF32M2XNT, y: _NF32M2XNT, /) -> bvec2: ...
@overload
def equal(x: glm_typing.F32Matrix2xAny, y: glm_typing.F32Matrix2xAny, ULPs_epsilon: Union[glm_typing.Number, ivec2, glm_typing.F32Vector2], /) -> bvec2: ...
@overload
def equal(x: _NF32M2XNT, y: _NF32M2XNT, ULPs_epsilon: Union[glm_typing.Number, ivec2, glm_typing.F32Vector2], /) -> bvec2: ...
@overload
def equal(x: glm_typing.F32Matrix3xAny, y: glm_typing.F32Matrix3xAny, /) -> bvec3: ...
@overload
def equal(x: _NF32M3XNT, y: _NF32M3XNT, /) -> bvec3: ...
@overload
def equal(x: glm_typing.F32Matrix3xAny, y: glm_typing.F32Matrix3xAny, ULPs_epsilon: Union[glm_typing.Number, ivec3, glm_typing.F32Vector3], /) -> bvec3: ...
@overload
def equal(x: _NF32M3XNT, y: _NF32M3XNT, ULPs_epsilon: Union[glm_typing.Number, ivec3, glm_typing.F32Vector3], /) -> bvec3: ...
@overload
def equal(x: glm_typing.F32Matrix4xAny, y: glm_typing.F32Matrix4xAny, /) -> bvec4: ...
@overload
def equal(x: _NF32M4XNT, y: _NF32M4XNT, /) -> bvec4: ...
@overload
def equal(x: glm_typing.F32Matrix4xAny, y: glm_typing.F32Matrix4xAny, ULPs_epsilon: Union[glm_typing.Number, ivec4, glm_typing.F32Vector4], /) -> bvec4: ...
@overload
def equal(x: _NF32M4XNT, y: _NF32M4XNT, ULPs_epsilon: Union[glm_typing.Number, ivec4, glm_typing.F32Vector4], /) -> bvec4: ...
@overload
def equal(x: _QT, y: _QT, /) -> int: ...

@overload
def greaterThan(x: _QT, y: _QT, /) -> bvec4: ...
@overload
def greaterThan(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, /) -> bvec1: ...
@overload
def greaterThan(x: _NF32V1T, y: _NF32V1T, /) -> bvec1: ...
@overload
def greaterThan(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, /) -> bvec2: ...
@overload
def greaterThan(x: _NF32V2T, y: _NF32V2T, /) -> bvec2: ...
@overload
def greaterThan(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, /) -> bvec3: ...
@overload
def greaterThan(x: _NF32V3T, y: _NF32V3T, /) -> bvec3: ...
@overload
def greaterThan(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, /) -> bvec4: ...
@overload
def greaterThan(x: _NF32V4T, y: _NF32V4T, /) -> bvec4: ...

@overload
def greaterThanEqual(x: _QT, y: _QT, /) -> bvec4: ...
@overload
def greaterThanEqual(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, /) -> bvec1: ...
@overload
def greaterThanEqual(x: _NF32V1T, y: _NF32V1T, /) -> bvec1: ...
@overload
def greaterThanEqual(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, /) -> bvec2: ...
@overload
def greaterThanEqual(x: _NF32V2T, y: _NF32V2T, /) -> bvec2: ...
@overload
def greaterThanEqual(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, /) -> bvec3: ...
@overload
def greaterThanEqual(x: _NF32V3T, y: _NF32V3T, /) -> bvec3: ...
@overload
def greaterThanEqual(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, /) -> bvec4: ...
@overload
def greaterThanEqual(x: _NF32V4T, y: _NF32V4T, /) -> bvec4: ...

@overload
def lessThan(x: _QT, y: _QT, /) -> bvec4: ...
@overload
def lessThan(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, /) -> bvec1: ...
@overload
def lessThan(x: _NF32V1T, y: _NF32V1T, /) -> bvec1: ...
@overload
def lessThan(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, /) -> bvec2: ...
@overload
def lessThan(x: _NF32V2T, y: _NF32V2T, /) -> bvec2: ...
@overload
def lessThan(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, /) -> bvec3: ...
@overload
def lessThan(x: _NF32V3T, y: _NF32V3T, /) -> bvec3: ...
@overload
def lessThan(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, /) -> bvec4: ...
@overload
def lessThan(x: _NF32V4T, y: _NF32V4T, /) -> bvec4: ...

@overload
def lessThanEqual(x: _QT, y: _QT, /) -> bvec4: ...
@overload
def lessThanEqual(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, /) -> bvec1: ...
@overload
def lessThanEqual(x: _NF32V1T, y: _NF32V1T, /) -> bvec1: ...
@overload
def lessThanEqual(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, /) -> bvec2: ...
@overload
def lessThanEqual(x: _NF32V2T, y: _NF32V2T, /) -> bvec2: ...
@overload
def lessThanEqual(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, /) -> bvec3: ...
@overload
def lessThanEqual(x: _NF32V3T, y: _NF32V3T, /) -> bvec3: ...
@overload
def lessThanEqual(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, /) -> bvec4: ...
@overload
def lessThanEqual(x: _NF32V4T, y: _NF32V4T, /) -> bvec4: ...

@overload
def notEqual(x: _QT, y: _QT, /) -> bvec4: ...
@overload
def notEqual(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, /) -> bvec1: ...
@overload
def notEqual(x: _NF32V1T, y: _NF32V1T, /) -> bvec1: ...
@overload
def notEqual(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, /) -> bvec2: ...
@overload
def notEqual(x: _NF32V2T, y: _NF32V2T, /) -> bvec2: ...
@overload
def notEqual(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, /) -> bvec3: ...
@overload
def notEqual(x: _NF32V3T, y: _NF32V3T, /) -> bvec3: ...
@overload
def notEqual(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, /) -> bvec4: ...
@overload
def notEqual(x: _NF32V4T, y: _NF32V4T, /) -> bvec4: ...

def not_(v: glm_typing.BAnyVectorAny, /) -> bool: ...


def add(a: Any, b: Any, /) -> Any: ...

def and_(a: Any, b: Any, /) -> Any: ...

def cmp(a: Any, b: Any, /) -> Any: ...

def div(a: Any, b: Any, /) -> Any: ...

def floordiv(a: Any, b: Any, /) -> Any: ...

def if_else(b: Any, x: Any, y: Any, /) -> Any: ...

def inv(a: Any, /) -> Any: ...

def lshift(a: Any, b: Any, /) -> Any: ...

def mul(a: Any, b: Any, /) -> Any: ...

def neg(a: Any, /) -> Any: ...

def or_(a: Any, b: Any, /) -> Any: ...

def pos(a: Any, /) -> Any: ...

def rshift(a: Any, b: Any, /) -> Any: ...

def sub(a: Any, b: Any, /) -> Any: ...

def xor(a: Any, b: Any, /) -> Any: ...



@overload
def convertLinearToSRGB(ColorLinear: glm_typing.F32Vector1) -> vec1: ...
@overload
def convertLinearToSRGB(ColorLinear: glm_typing.F32Vector1, Gamma: glm_typing.Number) -> vec1: ...
@overload
def convertLinearToSRGB(ColorLinear: glm_typing.F32Vector2) -> vec2: ...
@overload
def convertLinearToSRGB(ColorLinear: glm_typing.F32Vector2, Gamma: glm_typing.Number) -> vec2: ...
@overload
def convertLinearToSRGB(ColorLinear: glm_typing.F32Vector3) -> vec3: ...
@overload
def convertLinearToSRGB(ColorLinear: glm_typing.F32Vector3, Gamma: glm_typing.Number) -> vec3: ...
@overload
def convertLinearToSRGB(ColorLinear: glm_typing.F32Vector4) -> vec4: ...
@overload
def convertLinearToSRGB(ColorLinear: glm_typing.F32Vector4, Gamma: glm_typing.Number) -> vec4: ...
@overload
def convertLinearToSRGB(ColorLinear: _NF32DFVT) -> _NF32DFVT: ...
@overload
def convertLinearToSRGB(ColorLinear: _NF32DFVT, Gamma: glm_typing.Number) -> _NF32DFVT: ...

@overload
def convertSRGBToLinear(ColorLinear: glm_typing.F32Vector1) -> vec1: ...
@overload
def convertSRGBToLinear(ColorLinear: glm_typing.F32Vector1, Gamma: glm_typing.Number) -> vec1: ...
@overload
def convertSRGBToLinear(ColorLinear: glm_typing.F32Vector2) -> vec2: ...
@overload
def convertSRGBToLinear(ColorLinear: glm_typing.F32Vector2, Gamma: glm_typing.Number) -> vec2: ...
@overload
def convertSRGBToLinear(ColorLinear: glm_typing.F32Vector3) -> vec3: ...
@overload
def convertSRGBToLinear(ColorLinear: glm_typing.F32Vector3, Gamma: glm_typing.Number) -> vec3: ...
@overload
def convertSRGBToLinear(ColorLinear: glm_typing.F32Vector4) -> vec4: ...
@overload
def convertSRGBToLinear(ColorLinear: glm_typing.F32Vector4, Gamma: glm_typing.Number) -> vec4: ...
@overload
def convertSRGBToLinear(ColorLinear: _NF32DFVT) -> _NF32DFVT: ...
@overload
def convertSRGBToLinear(ColorLinear: _NF32DFVT, Gamma: glm_typing.Number) -> _NF32DFVT: ...


def e() -> float: ...

def epsilon() -> float: ...

def euler() -> float: ...

def four_over_pi() -> float: ...

def golden_ratio() -> float: ...

def half_pi() -> float: ...

def ln_ln_two() -> float: ...

def ln_ten() -> float: ...

def ln_two() -> float: ...

def one() -> float: ...

def one_over_pi() -> float: ...

def one_over_root_two() -> float: ...

def one_over_two_pi() -> float: ...

def pi() -> float: ...

def quarter_pi() -> float: ...

def root_five() -> float: ...

def root_half_pi() -> float: ...

def root_ln_four() -> float: ...

def root_pi() -> float: ...

def root_three() -> float: ...

def root_two() -> float: ...

def root_two_pi() -> float: ...

def third() -> float: ...

def three_over_two_pi() -> float: ...

def two_over_pi() -> float: ...

def two_over_root_pi() -> float: ...

def two_pi() -> float: ...

def two_thirds() -> float: ...

def zero() -> float: ...


@overload
def epsilonEqual(x: glm_typing.Number, y: glm_typing.Number, epsilon: glm_typing.Number, /) -> bool: ...
@overload
def epsilonEqual(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, epsilon: glm_typing.Number, /) -> bvec1: ...
@overload
def epsilonEqual(x: _NF32DFV1T, y: _NF32DFV1T, epsilon: glm_typing.Number, /) -> bvec1: ...
@overload
def epsilonEqual(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, epsilon: glm_typing.Number, /) -> bvec2: ...
@overload
def epsilonEqual(x: _NF32DFV2T, y: _NF32DFV2T, epsilon: glm_typing.Number, /) -> bvec2: ...
@overload
def epsilonEqual(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, epsilon: glm_typing.Number, /) -> bvec3: ...
@overload
def epsilonEqual(x: _NF32DFV3T, y: _NF32DFV3T, epsilon: glm_typing.Number, /) -> bvec3: ...
@overload
def epsilonEqual(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, epsilon: glm_typing.Number, /) -> bvec4: ...
@overload
def epsilonEqual(x: _NF32DFV4T, y: _NF32DFV4T, epsilon: glm_typing.Number, /) -> bvec4: ...

@overload
def epsilonNotEqual(x: glm_typing.Number, y: glm_typing.Number, epsilon: glm_typing.Number, /) -> bool: ...
@overload
def epsilonNotEqual(x: glm_typing.F32Vector1, y: glm_typing.F32Vector1, epsilon: glm_typing.Number, /) -> bvec1: ...
@overload
def epsilonNotEqual(x: _NF32DFV1T, y: _NF32DFV1T, epsilon: glm_typing.Number, /) -> bvec1: ...
@overload
def epsilonNotEqual(x: glm_typing.F32Vector2, y: glm_typing.F32Vector2, epsilon: glm_typing.Number, /) -> bvec2: ...
@overload
def epsilonNotEqual(x: _NF32DFV2T, y: _NF32DFV2T, epsilon: glm_typing.Number, /) -> bvec2: ...
@overload
def epsilonNotEqual(x: glm_typing.F32Vector3, y: glm_typing.F32Vector3, epsilon: glm_typing.Number, /) -> bvec3: ...
@overload
def epsilonNotEqual(x: _NF32DFV3T, y: _NF32DFV3T, epsilon: glm_typing.Number, /) -> bvec3: ...
@overload
def epsilonNotEqual(x: glm_typing.F32Vector4, y: glm_typing.F32Vector4, epsilon: glm_typing.Number, /) -> bvec4: ...
@overload
def epsilonNotEqual(x: _NF32DFV4T, y: _NF32DFV4T, epsilon: glm_typing.Number, /) -> bvec4: ...

__all__ = ['abs', 'acos', 'acosh', 'add', 'all', 'and_', 'any', 'array', 'asin', 'asinh', 'atan', 'atanh', 'bitCount', 'bitfieldExtract', 'bitfieldInsert', 'bitfieldReverse', 'bool_', 'bvec1', 'bvec2', 'bvec3', 'bvec4', 'c_int16', 'c_int32', 'c_int64', 'c_int8', 'c_uint16', 'c_uint32', 'c_uint64', 'c_uint8', 'ceil', 'clamp', 'cmp', 'convertLinearToSRGB', 'convertSRGBToLinear', 'cos', 'cosh', 'cross', 'degrees', 'determinant', 'distance', 'div', 'dmat2', 'dmat2x2', 'dmat2x3', 'dmat2x4', 'dmat3', 'dmat3x2', 'dmat3x3', 'dmat3x4', 'dmat4', 'dmat4x2', 'dmat4x3', 'dmat4x4', 'dmvec2', 'dmvec3', 'dmvec4', 'dot', 'double', 'dquat', 'dvec1', 'dvec2', 'dvec3', 'dvec4', 'e', 'epsilon', 'epsilonEqual', 'epsilonNotEqual', 'equal', 'euler', 'exp', 'exp2', 'f32mat2', 'f32mat2x2', 'f32mat2x3', 'f32mat2x4', 'f32mat3', 'f32mat3x2', 'f32mat3x3', 'f32mat3x4', 'f32mat4', 'f32mat4x2', 'f32mat4x3', 'f32mat4x4', 'f32quat', 'f32vec1', 'f32vec2', 'f32vec3', 'f32vec4', 'f64mat2', 'f64mat2x2', 'f64mat2x3', 'f64mat2x4', 'f64mat3', 'f64mat3x2', 'f64mat3x3', 'f64mat3x4', 'f64mat4', 'f64mat4x2', 'f64mat4x3', 'f64mat4x4', 'f64quat', 'f64vec1', 'f64vec2', 'f64vec3', 'f64vec4', 'faceforward', 'findLSB', 'findMSB', 'float32', 'float64', 'floatBitsToInt', 'floatBitsToUint', 'float_', 'floor', 'floordiv', 'fma', 'fmat2', 'fmat2x2', 'fmat2x3', 'fmat2x4', 'fmat3', 'fmat3x2', 'fmat3x3', 'fmat3x4', 'fmat4', 'fmat4x2', 'fmat4x3', 'fmat4x4', 'fmax', 'fmin', 'four_over_pi', 'fquat', 'fract', 'frexp', 'fvec1', 'fvec2', 'fvec3', 'fvec4', 'golden_ratio', 'greaterThan', 'greaterThanEqual', 'half_pi', 'i16vec1', 'i16vec2', 'i16vec3', 'i16vec4', 'i32mat2', 'i32mat2x2', 'i32mat2x3', 'i32mat2x4', 'i32mat3', 'i32mat3x2', 'i32mat3x3', 'i32mat3x4', 'i32mat4', 'i32mat4x2', 'i32mat4x3', 'i32mat4x4', 'i32vec1', 'i32vec2', 'i32vec3', 'i32vec4', 'i64vec1', 'i64vec2', 'i64vec3', 'i64vec4', 'i8vec1', 'i8vec2', 'i8vec3', 'i8vec4', 'if_else', 'imat2', 'imat2x2', 'imat2x3', 'imat2x4', 'imat3', 'imat3x2', 'imat3x3', 'imat3x4', 'imat4', 'imat4x2', 'imat4x3', 'imat4x4', 'imulExtended', 'imvec2', 'imvec3', 'imvec4', 'int16', 'int32', 'int64', 'int8', 'intBitsToFloat', 'inv', 'inverse', 'inversesqrt', 'isinf', 'isnan', 'ivec1', 'ivec2', 'ivec3', 'ivec4', 'ldexp', 'lessThan', 'lessThanEqual', 'ln_ln_two', 'ln_ten', 'ln_two', 'log', 'log2', 'lshift', 'mat2', 'mat2x2', 'mat2x3', 'mat2x4', 'mat3', 'mat3x2', 'mat3x3', 'mat3x4', 'mat4', 'mat4x2', 'mat4x3', 'mat4x4', 'matrixCompMult', 'max', 'min', 'mix', 'modf', 'mul', 'mvec2', 'mvec3', 'mvec4', 'neg', 'normalize', 'notEqual', 'not_', 'one', 'one_over_pi', 'one_over_root_two', 'or_', 'outerProduct', 'packDouble2x32', 'packHalf2x16', 'packSnorm2x16', 'packSnorm4x8', 'packUnorm2x16', 'packUnorm4x8', 'pi', 'pos', 'pow', 'quat', 'quater_pi', 'radians', 'reflect', 'refract', 'root_five', 'root_half_pi', 'root_ln_four', 'root_pi', 'root_three', 'root_two', 'root_two_pi', 'round', 'roundEven', 'rshift', 'sign', 'sin', 'sinh', 'smoothstep', 'sqrt', 'step', 'sub', 'tan', 'tanh', 'third', 'three_over_two_pi', 'transpose', 'trunc', 'two_over_pi', 'two_over_root_pi', 'two_pi', 'two_thirds', 'u16vec1', 'u16vec2', 'u16vec3', 'u16vec4', 'u32mat2', 'u32mat2x2', 'u32mat2x3', 'u32mat2x4', 'u32mat3', 'u32mat3x2', 'u32mat3x3', 'u32mat3x4', 'u32mat4', 'u32mat4x2', 'u32mat4x3', 'u32mat4x4', 'u32vec1', 'u32vec2', 'u32vec3', 'u32vec4', 'u64vec1', 'u64vec2', 'u64vec3', 'u64vec4', 'u8vec1', 'u8vec2', 'u8vec3', 'u8vec4', 'uaddCarry', 'uint16', 'uint32', 'uint64', 'uint8', 'uintBitsToFloat', 'umat2', 'umat2x2', 'umat2x3', 'umat2x4', 'umat3', 'umat3x2', 'umat3x3', 'umat3x4', 'umat4', 'umat4x2', 'umat4x3', 'umat4x4', 'umulExtended', 'umvec2', 'umvec3', 'umvec4', 'unpackDouble2x32', 'unpackHalf2x16', 'unpackSnorm2x16', 'unpackSnorm4x8', 'unpackUnorm2x16', 'unpackUnorm4x8', 'usubBorrow', 'uvec1', 'uvec2', 'uvec3', 'uvec4', 'vec1', 'vec2', 'vec3', 'vec4', 'xor', 'zero']
